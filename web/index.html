<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CineVault</title>
    <link rel="stylesheet" href="/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
    <script src="https://cdn.jsdelivr.net/npm/mpegts.js@1.8.0/dist/mpegts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <!-- Chart.js moved to settings.html with analytics -->
    <style>
        /* Page-specific overrides only — main styles in styles.css */
    </style>
</head>
<body>
    <!-- Sidebar Toggle (Mobile) -->
    <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()">&#9776;</button>
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>
    <!-- Login Intro Video -->
    <div class="intro-overlay" id="introOverlay">
        <video id="introVideo" preload="auto" playsinline>
            <source src="/assets/intro.mp4" type="video/mp4">
        </video>
    </div>

    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="logo">CineVault</div>

            <div class="nav-section">
                <div class="nav-label">Main</div>
                <div class="nav-item active" data-view="home"><span class="nav-icon">&#127968;</span><span>Home</span></div>
            </div>

            <div class="nav-section" id="librariesNav">
                <div class="nav-label">Libraries</div>
            </div>

            <div class="sidebar-footer" id="sidebarFooter"></div>
        </div>

        <!-- Main Content -->
        <div style="flex: 1; display: flex; flex-direction: column; min-width: 0;">
            <div class="top-bar">
                <div class="search-box">
                    <input type="text" placeholder="Search your media..." id="searchInput">
                </div>
                <div class="user-menu">
                    <div class="task-indicator" id="taskIndicator" style="display:none;">
                        <svg class="task-ring" viewBox="0 0 36 36">
                            <circle class="task-ring-bg" cx="18" cy="18" r="15.9155"/>
                            <circle class="task-ring-fill" id="taskRingFill" cx="18" cy="18" r="15.9155"
                                stroke-dasharray="100" stroke-dashoffset="100"
                                transform="rotate(-90 18 18)"/>
                        </svg>
                        <span class="task-count" id="taskCount"></span>
                        <div class="task-tooltip" id="taskTooltip"></div>
                    </div>
                    <span class="ws-status" id="wsStatus" style="display:none;"></span>
                    <div class="user-avatar" id="userAvatar">?</div>
                    <div class="user-dropdown" id="userDropdown">
                        <div class="user-dropdown-header">
                            <div class="user-dropdown-name" id="udName"></div>
                            <div class="user-dropdown-role" id="udRole"></div>
                        </div>
                        <div class="user-dropdown-item" onclick="openProfileSwitch()"><span class="ud-icon">&#128101;</span> Switch Profile</div>
                        <div class="user-dropdown-item" id="udManageProfilesItem" onclick="openManageProfiles()" style="display:none;"><span class="ud-icon">&#128100;</span> Manage Profiles</div>
                        <div class="user-dropdown-item" onclick="navigate('profile')"><span class="ud-icon">&#9998;</span> Edit Profile</div>
                        <div class="user-dropdown-item" id="udSettingsItem" onclick="window.location.href='settings.html'" style="display:none;"><span class="ud-icon">&#9881;</span> Settings</div>
                        <div class="user-dropdown-sep"></div>
                        <div class="user-dropdown-item logout" id="udLogoutBtn"><span class="ud-icon">&#128682;</span> Logout</div>
                    </div>
                </div>
            </div>
            <div class="main-content" id="mainContent"></div>
        </div>
    </div>

    <!-- Setup Wizard (first run) -->
    <div class="setup-overlay" id="setupOverlay">
        <div class="setup-card">
            <div class="setup-logo">CineVault Setup</div>
            <div class="setup-subtitle">Create your admin account to get started</div>
            <div id="setupMessage"></div>
            <form id="setupForm">
                <div class="form-group">
                    <label>Username</label>
                    <input type="text" id="setupUsername" required autocomplete="username">
                </div>
                <div class="setup-row">
                    <div class="form-group">
                        <label>First Name</label>
                        <input type="text" id="setupFirstName" required>
                    </div>
                    <div class="form-group">
                        <label>Last Name</label>
                        <input type="text" id="setupLastName" required>
                    </div>
                </div>
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" id="setupEmail" required autocomplete="email">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="setupPassword" required autocomplete="new-password">
                </div>
                <div class="form-group">
                    <label>PIN (for fast login)</label>
                    <input type="text" id="setupPin" inputmode="numeric" maxlength="10" autocomplete="off" placeholder="4-digit PIN">
                    <div class="setup-pin-note">Numeric only. Used for quick sign-in on shared devices.</div>
                </div>
                <button type="submit" class="btn-primary" style="width:100%;margin-top:16px;">Create Admin Account</button>
            </form>
        </div>
    </div>

    <!-- Login Modal (standard) -->
    <div class="modal" id="loginModal">
        <div class="modal-content">
            <h2 class="modal-title">Welcome to CineVault</h2>
            <div id="authMessage"></div>
            <form id="loginForm">
                <div class="form-group"><label>Username</label><input type="text" id="loginUsername" required></div>
                <div class="form-group"><label>Password</label><input type="password" id="loginPassword" required></div>
                <button type="submit" class="btn-primary" style="width: 100%; margin-top: 10px;">Login</button>
            </form>
        </div>
    </div>

    <!-- Fast Login Overlay -->
    <div class="fast-login-overlay" id="fastLoginOverlay">
        <div class="fast-login-back" id="fastLoginBack" style="display:none;" onclick="fastLoginShowUsers()">&#10094; Enter PIN</div>
        <div class="fast-login-title" id="fastLoginTitle">Select User</div>

        <!-- User Grid -->
        <div class="fast-login-grid" id="fastLoginGrid"></div>

        <!-- PIN Entry -->
        <div class="pin-entry-container" id="pinEntryContainer">
            <div class="pin-entry-user-info">
                <div class="pin-entry-user-card">
                    <div class="pin-entry-avatar" id="pinEntryAvatar"></div>
                    <div class="pin-entry-name" id="pinEntryName"></div>
                </div>
                <div>
                    <div class="pin-boxes" id="pinBoxes"></div>
                    <div class="pin-error" id="pinError"></div>
                </div>
            </div>
            <input type="text" class="pin-hidden-input" id="pinHiddenInput" inputmode="numeric" autocomplete="off" autofocus>
            <div class="pin-forgot" onclick="fastLoginShowStandard()">Use password instead</div>
        </div>

        <div class="fast-login-fallback" onclick="fastLoginShowStandard()">Use username &amp; password</div>
    </div>

    <!-- Profile Switch Overlay (post-login) -->
    <div class="profile-switch-overlay" id="profileSwitchOverlay">
        <div class="profile-switch-title">Switch Profile</div>
        <div class="profile-switch-grid" id="profileSwitchGrid"></div>
        <div class="profile-switch-close" onclick="closeProfileSwitch()">Cancel</div>
    </div>

    <!-- Household "Who's Watching?" Picker (shown after master login) -->
    <div class="household-picker-overlay" id="householdPickerOverlay">
        <div class="household-picker-title">Who's Watching?</div>
        <div class="household-picker-grid" id="householdPickerGrid"></div>
    </div>

    <!-- Shared hidden PIN input for profile switch / household picker (must be outside overlays so it's always focusable) -->
    <input type="text" id="hpPinHidden" inputmode="numeric" style="position:fixed;top:-9999px;left:-9999px;opacity:0;">

    <!-- Manage Profiles Modal -->
    <div class="manage-profiles-overlay" id="manageProfilesOverlay">
        <div class="manage-profiles-card">
            <div class="manage-profiles-close" onclick="closeManageProfiles()">&times;</div>
            <div class="manage-profiles-title">Manage Profiles</div>
            <div id="mpProfileList"></div>
            <button class="mp-add-btn" id="mpAddBtn" onclick="mpShowAddForm()">+ Add Profile</button>
            <div id="mpFormArea"></div>
        </div>
    </div>

    <!-- Video Player Overlay -->
    <div class="video-player-overlay" id="playerOverlay">
        <div class="player-top-bar">
            <span class="player-title" id="playerTitle"></span>
            <button class="player-close" onclick="closePlayer()">&#10005;</button>
        </div>
        <video id="videoPlayer"></video>
        <div class="skip-segment-btn" id="skipSegmentBtn" onclick="skipCurrentSegment()" style="display:none;">
            <span id="skipSegmentLabel">Skip Intro</span>
            <span class="skip-arrow">&#9654;&#9654;</span>
        </div>
        <div class="player-controls">
            <div class="player-progress" id="playerProgress" onclick="seekPlayer(event)">
                <div class="player-progress-fill" id="playerProgressFill"></div>
            </div>
            <div class="player-btns">
                <button class="player-btn" onclick="togglePlay()">&#9654;&#10074;&#10074;</button>
                <button class="player-btn" onclick="skipBack()">&#9194;</button>
                <button class="player-btn" onclick="skipForward()">&#9193;</button>
                <span class="player-time" id="playerTime">0:00 / 0:00</span>
                <button class="player-btn" onclick="toggleMute()">&#128266;</button>
                <select class="player-quality-select" id="qualitySelect" onchange="changeQuality(this.value)"></select>
                <button class="player-btn" onclick="toggleFullscreen()" style="margin-left:auto;">&#9974;</button>
            </div>
        </div>
    </div>

    <!-- Edit Media Modal -->
    <div class="edit-modal-overlay" id="editMediaOverlay">
        <div class="edit-modal">
            <div class="edit-modal-title">Edit Media Item</div>
            <input type="hidden" id="editMediaId">
            <div class="form-group">
                <label>Title *</label>
                <input type="text" id="editTitle">
            </div>
            <div class="edit-field-row">
                <div class="form-group">
                    <label>Sort Title</label>
                    <input type="text" id="editSortTitle" placeholder="Leave blank to use title">
                </div>
                <div class="form-group">
                    <label>Original Title</label>
                    <input type="text" id="editOriginalTitle" placeholder="Original language title">
                </div>
            </div>
            <div class="form-group">
                <label>Description</label>
                <textarea id="editDescription" rows="4" placeholder="Synopsis or description"></textarea>
            </div>
            <div class="edit-field-row">
                <div class="form-group">
                    <label>Year</label>
                    <input type="number" id="editYear" min="1800" max="2100" placeholder="e.g. 2024">
                </div>
                <div class="form-group">
                    <label>Release Date</label>
                    <input type="date" id="editReleaseDate">
                </div>
            </div>
            <div class="edit-field-row">
                <div class="form-group">
                    <label>Rating</label>
                    <input type="number" id="editRating" min="0" max="10" step="0.1" placeholder="0.0 – 10.0">
                </div>
                <div class="form-group">
                    <label>Edition</label>
                    <select id="editEditionType">
                        <option value="Theatrical">Theatrical</option>
                        <option value="Director's Cut">Director's Cut</option>
                        <option value="Extended">Extended</option>
                        <option value="Extended Edition">Extended Edition</option>
                        <option value="Unrated">Unrated</option>
                        <option value="Remastered">Remastered</option>
                        <option value="IMAX">IMAX</option>
                        <option value="4K Remaster">4K Remaster</option>
                        <option value="Special Edition">Special Edition</option>
                        <option value="Alternate">Alternate</option>
                    </select>
                </div>
            </div>
            <div class="form-group" id="parentMovieGroup" style="display:none;">
                <label>Parent Movie</label>
                <div class="parent-search-wrap">
                    <input type="text" id="parentMovieSearch" placeholder="Search for parent movie..." autocomplete="off" oninput="searchParentMovie(this.value)">
                    <input type="hidden" id="parentMovieId">
                    <div class="parent-search-results" id="parentSearchResults"></div>
                </div>
                <div id="parentCurrentInfo" style="display:none;"></div>
            </div>
            <div class="edit-field-row">
                <div class="form-group">
                    <label>Poster URL</label>
                    <input type="text" id="editPosterPath" placeholder="URL or local path to poster image">
                </div>
                <div class="form-group">
                    <label>Backdrop URL</label>
                    <input type="text" id="editBackdropPath" placeholder="URL or local path to backdrop image">
                </div>
            </div>
            <div class="form-group">
                <label>Custom Notes</label>
                <textarea id="editCustomNotes" rows="2" placeholder="Personal notes (e.g. Hybrid remux, AI upscale, etc.)"></textarea>
            </div>
            <div class="form-group">
                <label>Custom Tags <span style="color:#6b7b8d;font-weight:400;font-size:0.78rem;">(comma-separated)</span></label>
                <input type="text" id="editCustomTags" placeholder="e.g. reference, demo-disc, keeper">
            </div>
            <div id="editCastSection" style="margin-top:8px;">
                <span class="field-locks-toggle" id="editCastToggle" onclick="toggleEditCast()">
                    <span class="arrow">&#9656;</span> Cast &amp; Crew
                </span>
                <div id="editCastPanel" style="display:none;"></div>
            </div>
            <div id="editSeriesGroup" style="display:none; margin-top:8px;">
                <div id="editSeriesInfo"></div>
                <button class="btn-secondary" style="font-size:0.82rem; padding:8px 14px;" onclick="openSeriesModal()">&#127910; Add to Series</button>
            </div>
            <div id="editLockStatus" style="margin-top:8px;"></div>
            <div style="margin-top:4px;">
                <span class="field-locks-toggle" id="fieldLocksToggle" onclick="toggleFieldLocks()">
                    <span class="arrow">&#9656;</span> Per-Field Locks
                </span>
                <div id="fieldLocksPanel" style="display:none;">
                    <div class="field-locks-grid" id="fieldLocksGrid"></div>
                    <div style="font-size:0.72rem; color:#6b7b8d; margin-top:6px; padding:0 4px;">
                        Locked fields are protected from automatic updates during scans and auto-match.
                    </div>
                </div>
            </div>
            <div class="edit-modal-actions">
                <button class="btn-secondary" onclick="closeEditModal()">Cancel</button>
                <button class="btn-danger" id="editResetBtn" style="display:none;" onclick="resetMediaMeta()">&#8635; Reset Lock</button>
                <button class="btn-primary" onclick="saveMediaEdit()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Add to Series Modal -->
    <div class="series-modal-overlay" id="seriesModalOverlay">
        <div class="series-modal">
            <div class="series-modal-title">Add to Series</div>
            <input type="hidden" id="seriesMediaId">
            <div class="form-group">
                <label>Series Name</label>
                <div style="position:relative;">
                    <input type="text" id="seriesNameInput" placeholder="Select or type a new series name..." autocomplete="off" oninput="filterSeriesDropdown(this.value)" onfocus="showSeriesDropdown()">
                    <div id="seriesDropdown" style="position:absolute;top:100%;left:0;right:0;z-index:10;display:none;max-height:200px;overflow-y:auto;background:linear-gradient(135deg,#1a2332 0%,#0d1b2a 100%);border:1px solid rgba(0,217,255,0.25);border-radius:0 0 10px 10px;box-shadow:0 8px 32px rgba(0,0,0,0.5);"></div>
                </div>
                <input type="hidden" id="seriesSelectedId">
            </div>
            <div class="form-group">
                <label>Order in Series</label>
                <input type="number" id="seriesOrderInput" min="1" placeholder="e.g. 1, 2, 3..." value="1">
            </div>
            <div class="series-modal-actions">
                <button class="btn-secondary" onclick="closeSeriesModal()">Cancel</button>
                <button class="btn-primary" onclick="saveToSeries()">Save</button>
            </div>
        </div>
    </div>

    <!-- Merge as Edition Modal -->
    <div class="merge-modal-overlay" id="mergeEditionOverlay">
        <div class="merge-modal">
            <div class="merge-modal-title">Merge as Edition</div>
            <input type="hidden" id="mergeItemA">
            <input type="hidden" id="mergeItemB">
            <div class="form-group">
                <label>Edition Label</label>
                <select id="mergeEditionLabel">
                    <option value="Theatrical">Theatrical</option>
                    <option value="Director's Cut">Director's Cut</option>
                    <option value="Extended">Extended</option>
                    <option value="Unrated">Unrated</option>
                    <option value="IMAX">IMAX</option>
                    <option value="4K Remaster">4K Remaster</option>
                    <option value="Special Edition">Special Edition</option>
                    <option value="Alternate">Alternate</option>
                </select>
            </div>
            <div class="form-group">
                <label>Select Primary Item</label>
                <div id="mergePrimaryOptions"></div>
            </div>
            <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:20px;">
                <button class="btn-secondary" onclick="closeMergeModal()">Cancel</button>
                <button class="btn-primary" onclick="submitMergeEdition()" style="background:linear-gradient(135deg,#a855f7,#7c3aed);">Merge</button>
            </div>
        </div>
    </div>

    <!-- Edition Picker Modal -->
    <div class="edition-picker-overlay" id="editionPickerOverlay">
        <div class="edition-picker">
            <div class="edition-picker-title">Select Edition to Play</div>
            <div id="editionPickerList"></div>
            <div style="display:flex;justify-content:flex-end;margin-top:20px;">
                <button class="btn-secondary" onclick="closeEditionPicker()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Library Context Menu (shared, fixed-position) -->
    <div class="lib-ctx-menu" id="libCtxMenu"></div>

    <!-- Bulk Action Bar -->
    <div class="bulk-action-bar" id="bulkActionBar">
        <div class="bulk-bar-left">
            <span class="bulk-count" id="bulkCount">0 selected</span>
            <button onclick="selectAllVisible()">Select All</button>
        </div>
        <div class="bulk-bar-actions">
            <button onclick="openBulkEditModal()">&#9998; Edit</button>
            <button onclick="bulkMarkPlayed()">&#9989; Played</button>
            <button onclick="bulkMarkUnplayed()">&#9711; Unplayed</button>
            <button onclick="bulkRefreshMetadata()">&#8635; Refresh</button>
            <button onclick="openBulkAddToCollection()">&#128218; Collection</button>
            <button class="bulk-btn-danger" onclick="bulkDelete()">&#128465; Delete</button>
        </div>
        <div class="bulk-bar-right">
            <button onclick="selectionState.clear()">&#10005; Cancel</button>
        </div>
    </div>

    <!-- Bulk Edit Modal -->
    <div class="bulk-edit-overlay" id="bulkEditOverlay">
        <div class="bulk-edit-modal">
            <div class="bulk-edit-title">Bulk Edit</div>
            <div class="bulk-edit-subtitle" id="bulkEditSubtitle">Editing 0 items — only checked fields will be applied</div>

            <div class="bulk-field-row" id="bfRating">
                <div class="bulk-field-check"><input type="checkbox" id="bfRatingCheck" onchange="toggleBulkField('bfRating')"></div>
                <div class="bulk-field-body">
                    <label>Rating</label>
                    <input type="number" id="bfRatingVal" min="0" max="10" step="0.1" placeholder="0.0 – 10.0" disabled>
                </div>
            </div>

            <div class="bulk-field-row" id="bfEdition">
                <div class="bulk-field-check"><input type="checkbox" id="bfEditionCheck" onchange="toggleBulkField('bfEdition')"></div>
                <div class="bulk-field-body">
                    <label>Edition Type</label>
                    <select id="bfEditionVal" disabled>
                        <option value="Theatrical">Theatrical</option>
                        <option value="Director's Cut">Director's Cut</option>
                        <option value="Extended">Extended</option>
                        <option value="Extended Edition">Extended Edition</option>
                        <option value="Unrated">Unrated</option>
                        <option value="Remastered">Remastered</option>
                        <option value="IMAX">IMAX</option>
                        <option value="4K Remaster">4K Remaster</option>
                        <option value="Special Edition">Special Edition</option>
                        <option value="Alternate">Alternate</option>
                    </select>
                </div>
            </div>

            <div class="bulk-field-row" id="bfTags">
                <div class="bulk-field-check"><input type="checkbox" id="bfTagsCheck" onchange="toggleBulkField('bfTags')"></div>
                <div class="bulk-field-body">
                    <label>Custom Tags</label>
                    <div class="bulk-tag-mode">
                        <button class="active" id="bfTagModeAdd" onclick="setBulkTagMode('add')">+ Add</button>
                        <button id="bfTagModeRemove" onclick="setBulkTagMode('remove')">- Remove</button>
                        <button id="bfTagModeReplace" onclick="setBulkTagMode('replace')">Replace</button>
                    </div>
                    <input type="text" id="bfTagsVal" placeholder="e.g. reference, demo-disc, keeper" disabled>
                </div>
            </div>

            <div class="bulk-field-row" id="bfNotes">
                <div class="bulk-field-check"><input type="checkbox" id="bfNotesCheck" onchange="toggleBulkField('bfNotes')"></div>
                <div class="bulk-field-body">
                    <label>Custom Notes</label>
                    <div class="bulk-tag-mode">
                        <button class="active" id="bfNotesModeAppend" onclick="setBulkNotesMode('append')">Append</button>
                        <button id="bfNotesModeReplace" onclick="setBulkNotesMode('replace')">Replace</button>
                    </div>
                    <textarea id="bfNotesVal" rows="2" placeholder="Notes to apply..." disabled></textarea>
                </div>
            </div>

            <div class="bulk-edit-actions">
                <button class="btn-secondary" onclick="closeBulkEditModal()">Cancel</button>
                <button class="btn-primary" onclick="saveBulkEdit()">Apply to All</button>
            </div>
        </div>
    </div>

    <!-- Collection Picker Modal -->
    <div class="collection-picker-overlay" id="collectionPickerOverlay">
        <div class="collection-picker-modal">
            <div class="collection-picker-title">Add to Collection</div>
            <div class="picker-create-row" id="pickerCreateRow">
                <input type="text" id="pickerNewCollName" placeholder="New collection name..." class="picker-create-input">
                <button class="btn-primary btn-small" onclick="pickerCreateCollection()">Create</button>
            </div>
            <div class="collection-picker-list" id="collectionPickerList">
                <div class="spinner"></div> Loading collections...
            </div>
            <div class="collection-picker-actions">
                <button class="btn-secondary" onclick="closeCollectionPicker()">Cancel</button>
                <button class="btn-primary" onclick="saveToCollections()">Add Selected</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
    const API = '/api/v1';
    let currentUser = null;
    let allLibraries = [];
    let ws = null;
    // Overlay badge display preferences (fetched from server per-user)
    let overlayPrefs = { resolution_hdr: true, audio_codec: true, ratings: true, content_rating: false, edition_type: true, source_type: false };
    let hlsPlayer = null;
    let mpegtsPlayer = null;
    let currentMediaId = null;
    const activeTasks = {};
    let taskFadeTimer = null;

    function headers() { return { 'Authorization': 'Bearer ' + localStorage.getItem('token'), 'Content-Type': 'application/json' }; }

    async function api(method, path, body) {
        const opts = { method, headers: headers() };
        if (body) opts.body = JSON.stringify(body);
        try { const res = await fetch(API + path, opts); return res.json(); } catch(e) { return { success: false, error: e.message }; }
    }

    function toast(msg, type='success') {
        const c = document.getElementById('toastContainer');
        const t = document.createElement('div');
        t.className = 'toast message ' + type;
        t.textContent = msg;
        c.appendChild(t);
        setTimeout(() => t.remove(), 4000);
    }

    const MEDIA_ICONS = { movies:'&#127916;', adult_movies:'&#128274;', tv_shows:'&#128250;', music:'&#127925;', music_videos:'&#127911;', home_videos:'&#127909;', other_videos:'&#128253;', images:'&#128247;', audiobooks:'&#128214;' };
    const MEDIA_LABELS = { movies:'Movies', adult_movies:'Adult Movies', tv_shows:'TV Shows', music:'Music', music_videos:'Music Videos', home_videos:'Home Videos', other_videos:'Other Videos', images:'Photos', audiobooks:'Audiobooks' };
    function mediaIcon(type) { return MEDIA_ICONS[type] || '&#128191;'; }
    function posterSrc(path, updatedAt) { if (!path) return ''; const ts = updatedAt ? new Date(updatedAt).getTime() : Date.now(); return path + '?v=' + ts; }
    async function fetchOverlayPrefs() {
        try {
            const res = await api('GET', '/settings/display');
            if (res.success && res.data && res.data.overlay_settings) {
                overlayPrefs = res.data.overlay_settings;
            }
        } catch(e) { /* keep defaults */ }
    }
    function formatDuration(sec) { if (!sec) return ''; const m = Math.floor(sec/60); const s = sec%60; return m + ':' + String(s).padStart(2,'0'); }
    function formatTime(sec) { const h = Math.floor(sec/3600); const m = Math.floor((sec%3600)/60); const s = Math.floor(sec%60); return (h>0?h+':':'')+String(m).padStart(h>0?2:1,'0')+':'+String(s).padStart(2,'0'); }

    // ──── Multi-Select State Manager ────
    const selectionState = {
        active: false,
        selectedIds: new Set(),
        lastClickedId: null,
        tagMode: 'add',     // add | remove | replace
        notesMode: 'append', // append | replace

        toggle(id, shiftKey) {
            if (shiftKey && this.lastClickedId && this.lastClickedId !== id) {
                this._rangeSelect(id);
            } else if (this.selectedIds.has(id)) {
                this.selectedIds.delete(id);
            } else {
                this.selectedIds.add(id);
            }
            this.lastClickedId = id;
            this._sync();
        },

        _rangeSelect(id) {
            const cards = Array.from(document.querySelectorAll('.media-card[data-media-id]'));
            const ids = cards.map(c => c.dataset.mediaId);
            const startIdx = ids.indexOf(this.lastClickedId);
            const endIdx = ids.indexOf(id);
            if (startIdx === -1 || endIdx === -1) return;
            const lo = Math.min(startIdx, endIdx);
            const hi = Math.max(startIdx, endIdx);
            for (let i = lo; i <= hi; i++) {
                this.selectedIds.add(ids[i]);
            }
        },

        selectAll() {
            document.querySelectorAll('.media-card[data-media-id]').forEach(c => {
                this.selectedIds.add(c.dataset.mediaId);
            });
            this._sync();
        },

        clear() {
            this.selectedIds.clear();
            this.lastClickedId = null;
            this._sync();
        },

        count() { return this.selectedIds.size; },

        _sync() {
            const n = this.selectedIds.size;
            this.active = n > 0;

            // Toggle body class
            document.body.classList.toggle('select-mode', this.active);

            // Update action bar
            const bar = document.getElementById('bulkActionBar');
            bar.classList.toggle('visible', this.active);
            document.getElementById('bulkCount').textContent = n + ' selected';

            // Update card visual state
            document.querySelectorAll('.media-card[data-media-id]').forEach(card => {
                card.classList.toggle('selected', this.selectedIds.has(card.dataset.mediaId));
            });
        }
    };

    function handleCardClick(id, event) {
        if (selectionState.active) {
            event.preventDefault();
            event.stopPropagation();
            selectionState.toggle(id, event.shiftKey);
        } else {
            loadMediaDetail(id);
        }
    }

    function handleCheckboxClick(id, event) {
        event.preventDefault();
        event.stopPropagation();
        selectionState.toggle(id, event.shiftKey);
    }

    function selectAllVisible() {
        selectionState.selectAll();
    }

    // ──── Bulk Edit Modal Logic ────
    function toggleBulkField(rowId) {
        const row = document.getElementById(rowId);
        const check = row.querySelector('input[type="checkbox"]');
        const inputs = row.querySelectorAll('.bulk-field-body input, .bulk-field-body select, .bulk-field-body textarea');
        row.classList.toggle('active', check.checked);
        inputs.forEach(inp => inp.disabled = !check.checked);
    }

    function setBulkTagMode(mode) {
        selectionState.tagMode = mode;
        document.getElementById('bfTagModeAdd').classList.toggle('active', mode === 'add');
        document.getElementById('bfTagModeRemove').classList.toggle('active', mode === 'remove');
        document.getElementById('bfTagModeReplace').classList.toggle('active', mode === 'replace');
    }

    function setBulkNotesMode(mode) {
        selectionState.notesMode = mode;
        document.getElementById('bfNotesModeAppend').classList.toggle('active', mode === 'append');
        document.getElementById('bfNotesModeReplace').classList.toggle('active', mode === 'replace');
    }

    function openBulkEditModal() {
        if (selectionState.count() === 0) return;
        document.getElementById('bulkEditSubtitle').textContent =
            'Editing ' + selectionState.count() + ' items — only checked fields will be applied';
        // Reset fields
        ['bfRatingCheck','bfEditionCheck','bfTagsCheck','bfNotesCheck'].forEach(id => {
            document.getElementById(id).checked = false;
        });
        ['bfRating','bfEdition','bfTags','bfNotes'].forEach(id => {
            const row = document.getElementById(id);
            row.classList.remove('active');
            row.querySelectorAll('.bulk-field-body input, .bulk-field-body select, .bulk-field-body textarea')
                .forEach(inp => { inp.disabled = true; inp.value = ''; });
        });
        setBulkTagMode('add');
        setBulkNotesMode('append');
        document.getElementById('bulkEditOverlay').classList.add('active');
    }

    function closeBulkEditModal() {
        document.getElementById('bulkEditOverlay').classList.remove('active');
    }

    async function saveBulkEdit() {
        const ids = Array.from(selectionState.selectedIds);
        if (ids.length === 0) return;
        const fields = {};

        if (document.getElementById('bfRatingCheck').checked) {
            const v = document.getElementById('bfRatingVal').value;
            if (v !== '') fields.rating = parseFloat(v);
        }
        if (document.getElementById('bfEditionCheck').checked) {
            fields.edition_type = document.getElementById('bfEditionVal').value;
        }
        if (document.getElementById('bfTagsCheck').checked) {
            fields.custom_tags = document.getElementById('bfTagsVal').value;
            fields.tag_mode = selectionState.tagMode;
        }
        if (document.getElementById('bfNotesCheck').checked) {
            fields.custom_notes = document.getElementById('bfNotesVal').value;
            fields.notes_mode = selectionState.notesMode;
        }

        if (Object.keys(fields).length === 0) {
            toast('No fields selected to apply', 'error');
            return;
        }

        const res = await api('PUT', '/media/bulk', { ids, fields });
        if (res.success) {
            toast('Updated ' + ids.length + ' items');
            closeBulkEditModal();
            selectionState.clear();
        } else {
            toast(res.error || 'Bulk update failed', 'error');
        }
    }

    // ──── Bulk Actions ────
    async function bulkMarkPlayed() {
        const ids = Array.from(selectionState.selectedIds);
        if (ids.length === 0) return;
        const res = await api('POST', '/media/bulk-action', { ids, action: 'mark_played' });
        if (res.success) { toast(ids.length + ' items marked as played'); selectionState.clear(); }
        else toast(res.error || 'Failed', 'error');
    }

    async function bulkMarkUnplayed() {
        const ids = Array.from(selectionState.selectedIds);
        if (ids.length === 0) return;
        const res = await api('POST', '/media/bulk-action', { ids, action: 'mark_unplayed' });
        if (res.success) { toast(ids.length + ' items marked as unplayed'); selectionState.clear(); }
        else toast(res.error || 'Failed', 'error');
    }

    async function bulkRefreshMetadata() {
        const ids = Array.from(selectionState.selectedIds);
        if (ids.length === 0) return;
        const res = await api('POST', '/media/bulk-action', { ids, action: 'refresh_metadata' });
        if (res.success) { toast('Metadata refresh queued for ' + ids.length + ' items'); selectionState.clear(); }
        else toast(res.error || 'Failed', 'error');
    }

    async function bulkDelete() {
        const ids = Array.from(selectionState.selectedIds);
        if (ids.length === 0) return;
        if (!confirm('Delete ' + ids.length + ' media items? This cannot be undone.')) return;
        const res = await api('POST', '/media/bulk-action', { ids, action: 'delete' });
        if (res.success) {
            toast(ids.length + ' items deleted');
            selectionState.clear();
            // Reload current view
            const mc = document.getElementById('mainContent');
            document.querySelectorAll('.media-card').forEach(c => {
                if (ids.includes(c.dataset.mediaId)) c.remove();
            });
        } else toast(res.error || 'Delete failed', 'error');
    }

    // ──── Collection Picker ────
    let _pickerSelectedCollections = new Set();

    async function openBulkAddToCollection() {
        if (selectionState.count() === 0) return;
        _pickerSelectedCollections.clear();
        document.getElementById('pickerNewCollName').value = '';
        const list = document.getElementById('collectionPickerList');
        list.innerHTML = '<div class="spinner"></div> Loading...';
        document.getElementById('collectionPickerOverlay').classList.add('active');
        await _refreshPickerList();
    }

    async function _refreshPickerList() {
        const list = document.getElementById('collectionPickerList');
        const res = await api('GET', '/collections');
        const collections = (res.success && res.data) ? res.data.filter(c => c.collection_type !== 'smart') : [];
        if (collections.length === 0) {
            list.innerHTML = '<div style="color:var(--text-tertiary);padding:12px;">No manual collections yet. Create one above.</div>';
            return;
        }
        list.innerHTML = collections.map(c => `
            <div class="collection-picker-item${_pickerSelectedCollections.has(c.id) ? ' selected' : ''}" onclick="togglePickerCollection('${c.id}', this)">
                <input type="checkbox"${_pickerSelectedCollections.has(c.id) ? ' checked' : ''} onclick="event.stopPropagation();">
                <span>${c.name}</span>
            </div>
        `).join('');
    }

    async function pickerCreateCollection() {
        const input = document.getElementById('pickerNewCollName');
        const name = input.value.trim();
        if (!name) { toast('Enter a collection name', 'error'); return; }
        const body = { name, collection_type: 'manual', visibility: 'private' };
        // Attach library context so the collection appears in library-scoped views
        if (_gridState.libraryId) {
            body.library_id = _gridState.libraryId;
        }
        const res = await api('POST', '/collections', body);
        if (res.success) {
            toast('Collection "' + name + '" created');
            input.value = '';
            // Auto-select the newly created collection
            if (res.data && res.data.id) {
                _pickerSelectedCollections.add(res.data.id);
            }
            await _refreshPickerList();
        } else {
            toast(res.error || 'Failed to create collection', 'error');
        }
    }

    function togglePickerCollection(id, el) {
        const cb = el.querySelector('input[type="checkbox"]');
        if (_pickerSelectedCollections.has(id)) {
            _pickerSelectedCollections.delete(id);
            cb.checked = false;
            el.classList.remove('selected');
        } else {
            _pickerSelectedCollections.add(id);
            cb.checked = true;
            el.classList.add('selected');
        }
    }

    function closeCollectionPicker() {
        document.getElementById('collectionPickerOverlay').classList.remove('active');
    }

    async function saveToCollections() {
        const mediaIds = Array.from(selectionState.selectedIds);
        const collIds = Array.from(_pickerSelectedCollections);
        if (collIds.length === 0) { toast('Select at least one collection', 'error'); return; }

        let added = 0;
        for (const collId of collIds) {
            const items = mediaIds.map((mid, i) => ({ media_item_id: mid, position: i }));
            const res = await api('POST', '/collections/' + collId + '/items/bulk', items);
            if (res.success) added++;
        }
        toast('Added ' + mediaIds.length + ' items to ' + added + ' collection' + (added !== 1 ? 's' : ''));
        closeCollectionPicker();
        selectionState.clear();
    }

    // ──── Task Activity Tracker ────
    function handleTaskUpdate(data) {
        const taskId = data.task_id;
        if (!taskId) return;
        if (data.status === 'complete' || data.status === 'failed') {
            delete activeTasks[taskId];
            // Keep indicator visible briefly after last task completes
            if (Object.keys(activeTasks).length === 0) {
                clearTimeout(taskFadeTimer);
                taskFadeTimer = setTimeout(() => updateTaskIndicator(), 2000);
                // Show 100% momentarily
                const ring = document.getElementById('taskRingFill');
                if (ring) ring.setAttribute('stroke-dashoffset', '0');
                return;
            }
        } else {
            clearTimeout(taskFadeTimer);
            activeTasks[taskId] = {
                type: data.task_type || 'unknown',
                description: data.description || data.task_type || 'Task',
                progress: data.progress || 0,
                status: data.status || 'running'
            };
        }
        updateTaskIndicator();
    }

    function updateTaskIndicator() {
        const indicator = document.getElementById('taskIndicator');
        const tasks = Object.values(activeTasks);
        const count = tasks.length;
        if (count === 0) {
            indicator.style.display = 'none';
            indicator.classList.remove('active');
            return;
        }
        indicator.style.display = '';
        indicator.classList.add('active');
        // Aggregate progress (average across all active tasks)
        const avgProgress = tasks.reduce((sum, t) => sum + (t.progress || 0), 0) / count;
        const ring = document.getElementById('taskRingFill');
        if (ring) ring.setAttribute('stroke-dashoffset', String(100 - avgProgress));
        // Task count
        const countEl = document.getElementById('taskCount');
        if (countEl) countEl.textContent = count;
        // Tooltip
        const tooltip = document.getElementById('taskTooltip');
        if (tooltip) {
            tooltip.innerHTML = '<div class="task-tooltip-header">Active Tasks</div>' +
                tasks.map(t => `<div class="task-tooltip-item">
                    <div class="task-tooltip-name">${t.description}</div>
                    <div class="task-tooltip-progress">
                        <div class="task-tooltip-bar"><div class="task-tooltip-bar-fill" style="width:${Math.round(t.progress)}%"></div></div>
                        <span class="task-tooltip-pct">${Math.round(t.progress)}%</span>
                    </div>
                </div>`).join('');
        }
    }

    // ──── WebSocket ────
    function connectWS() {
        if (ws) ws.close();
        const token = localStorage.getItem('token');
        if (!token) return;
        const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(`${proto}//${location.host}/api/v1/ws?token=${token}`);
        const badge = document.getElementById('wsStatus');
        ws.onopen = () => { badge.style.display=''; badge.className='ws-status tag tag-green'; badge.textContent='Live'; };
        ws.onclose = () => { badge.className='ws-status tag tag-red'; badge.textContent='Offline'; setTimeout(connectWS, 5000); };
        ws.onmessage = (e) => {
            try {
                const msg = JSON.parse(e.data);
                handleWSEvent(msg);
            } catch {}
        };
    }

    function handleWSEvent(msg) {
        switch(msg.event) {
            case 'scan:start': {
                toast('Scanning: ' + (msg.data?.name || ''), 'success');
                const libId = msg.data?.library_id;
                if (libId) {
                    const prog = document.getElementById('scan-progress-' + libId);
                    if (prog) prog.classList.add('active');
                    const btn = document.getElementById('scan-btn-' + libId);
                    if (btn) { btn.disabled = true; btn.innerHTML = '<span class="spinner"></span>Scanning...'; }
                }
                break;
            }
            case 'scan:progress': {
                const libId = msg.data?.library_id;
                if (!libId) break;
                const current = msg.data.current || 0;
                const total = msg.data.total || 0;
                const filename = msg.data.filename || '';
                const pct = total > 0 ? Math.round((current / total) * 100) : 0;
                const fill = document.getElementById('scan-fill-' + libId);
                if (fill) fill.style.width = pct + '%';
                const fileEl = document.getElementById('scan-file-' + libId);
                if (fileEl) fileEl.textContent = filename;
                const countEl = document.getElementById('scan-count-' + libId);
                if (countEl) countEl.textContent = current + ' / ' + total + ' (' + pct + '%)';
                const prog = document.getElementById('scan-progress-' + libId);
                if (prog && !prog.classList.contains('active')) prog.classList.add('active');
                break;
            }
            case 'scan:complete': {
                const r = msg.data?.result;
                toast(`Scan complete: ${r?.files_added||0} added, ${r?.files_found||0} found`);
                loadSidebarCounts();
                const libId = msg.data?.library_id;
                if (libId) {
                    const fill = document.getElementById('scan-fill-' + libId);
                    if (fill) fill.style.width = '100%';
                    const btn = document.getElementById('scan-btn-' + libId);
                    if (btn) { btn.disabled = false; btn.innerHTML = '&#128269; Scan'; }
                    setTimeout(() => {
                        const prog = document.getElementById('scan-progress-' + libId);
                        if (prog) prog.classList.remove('active');
                        if (fill) fill.style.width = '0%';
                    }, 3000);
                    loadLibrariesView();
                }
                break;
            }
            case 'task:update':
                handleTaskUpdate(msg.data);
                break;
            case 'job:progress': break;
            default: break;
        }
    }

    // ──── Auth ────
    let fastLoginConfig = null;
    let fastLoginUsers = [];
    let selectedFastUser = null;
    let pinLength = 4;

    async function checkAuth() {
        // Always check if first-run setup is needed (handles stale tokens after DB reset)
        try {
            const setupRes = await fetch(API + '/setup/check');
            const setupData = await setupRes.json();
            if (setupData.success && setupData.data && setupData.data.setup_required) {
                localStorage.removeItem('token');
                localStorage.removeItem('user');
                document.getElementById('loginModal').classList.remove('active');
                document.getElementById('fastLoginOverlay').classList.remove('active');
                document.getElementById('setupOverlay').classList.add('active');
                return;
            }
        } catch(e) { /* setup check failed, continue normally */ }

        const token = localStorage.getItem('token');
        const user = localStorage.getItem('user');
        if (token && user) {
            currentUser = JSON.parse(user);
            document.getElementById('loginModal').classList.remove('active');
            document.getElementById('fastLoginOverlay').classList.remove('active');
            document.getElementById('setupOverlay').classList.remove('active');
            document.getElementById('userAvatar').textContent = currentUser.username[0].toUpperCase();

            // Play intro if enabled and not yet played this session
            if (!sessionStorage.getItem('intro_played')) {
                if (!fastLoginConfig) {
                    try {
                        const res = await fetch(API + '/auth/fast-login/settings');
                        fastLoginConfig = await res.json();
                    } catch(e) { fastLoginConfig = { success: false }; }
                }
                const introEnabled = fastLoginConfig && fastLoginConfig.success && fastLoginConfig.data && fastLoginConfig.data.login_intro_enabled === 'true';
                if (introEnabled) {
                    const played = await playLoginIntro(fastLoginConfig.data.login_intro_muted === 'true');
                    if (played) sessionStorage.setItem('intro_played', '1');
                }
            }

            // Fetch overlay display preferences
            fetchOverlayPrefs();

            // If we haven't picked a profile yet this session (master user), show picker
            if (!sessionStorage.getItem('profile_picked') && !currentUser.parent_user_id) {
                showHouseholdPicker();
            } else {
                loadHomeView();
            }
            loadSidebarCounts();
            connectWS();
        } else {
            try {
                const res = await fetch(API + '/auth/fast-login/settings');
                fastLoginConfig = await res.json();
            } catch { fastLoginConfig = { success: false }; }

            if (fastLoginConfig && fastLoginConfig.success && fastLoginConfig.data && fastLoginConfig.data.fast_login_enabled === 'true') {
                pinLength = parseInt(fastLoginConfig.data.fast_login_pin_length) || 4;
                showFastLogin();
            } else {
                document.getElementById('loginModal').classList.add('active');
            }
        }
    }

    // ──── Fast Login ────
    async function showFastLogin() {
        document.getElementById('fastLoginOverlay').classList.add('active');
        document.getElementById('loginModal').classList.remove('active');
        try {
            const res = await fetch(API + '/auth/fast-login/users');
            const data = await res.json();
            fastLoginUsers = data.success ? (data.data || []) : [];
        } catch { fastLoginUsers = []; }
        fastLoginShowUsers();
    }

    function userColor(name) {
        const colors = [
            ['#6c9a8b','#8fb8a8'],['#9a8b6c','#b8a88f'],['#6c7d9a','#8f9db8'],
            ['#9a6c7d','#b88f9d'],['#7d9a6c','#9db88f'],['#8b6c9a','#a88fb8'],
            ['#6c9a9a','#8fb8b8'],['#9a9a6c','#b8b88f']
        ];
        let hash = 0;
        for (let i = 0; i < name.length; i++) hash = name.charCodeAt(i) + ((hash << 5) - hash);
        return colors[Math.abs(hash) % colors.length];
    }

    function fastLoginShowUsers() {
        const grid = document.getElementById('fastLoginGrid');
        const pinEntry = document.getElementById('pinEntryContainer');
        const back = document.getElementById('fastLoginBack');
        const title = document.getElementById('fastLoginTitle');
        const fallback = document.querySelector('.fast-login-fallback');
        grid.style.display = 'flex';
        pinEntry.classList.remove('active');
        back.style.display = 'none';
        title.textContent = 'Select User';
        if (fallback) fallback.style.display = '';
        selectedFastUser = null;

        grid.innerHTML = fastLoginUsers.map(u => {
            const dn = u.display_name || u.username;
            const initial = dn[0].toUpperCase();
            const [bg, circle] = userColor(dn);
            let badges = '';
            if (u.has_pin) badges += '<span class="fast-login-badge pin-set">&#128274;</span>';
            if (u.role === 'admin') badges += '<span class="fast-login-badge admin">&#128081;</span>';
            return '<div class="fast-login-user" onclick="fastLoginSelectUser(\'' + u.id + '\')" style="background:linear-gradient(145deg, ' + bg + '33 0%, ' + bg + '11 100%);border-color:' + bg + '44;">' +
                '<div class="fast-login-avatar" style="background:radial-gradient(circle, ' + circle + ' 0%, ' + bg + ' 100%);">' + initial +
                '<div class="fast-login-badges" style="position:absolute;bottom:-4px;left:0;right:0;">' + badges + '</div></div>' +
                '<div class="fast-login-user-name">' + dn + '</div></div>';
        }).join('');
    }

    function fastLoginSelectUser(userId) {
        selectedFastUser = fastLoginUsers.find(u => u.id === userId);
        if (!selectedFastUser) return;
        if (!selectedFastUser.has_pin) { fastLoginShowStandard(); return; }

        document.getElementById('fastLoginGrid').style.display = 'none';
        document.getElementById('pinEntryContainer').classList.add('active');
        document.getElementById('fastLoginBack').style.display = 'flex';
        document.getElementById('fastLoginTitle').textContent = 'Enter PIN';
        const fallback = document.querySelector('.fast-login-fallback');
        if (fallback) fallback.style.display = 'none';

        const dn = selectedFastUser.display_name || selectedFastUser.username;
        const [bg, circle] = userColor(dn);
        document.getElementById('pinEntryAvatar').style.background = 'radial-gradient(circle, ' + circle + ' 0%, ' + bg + ' 100%)';
        document.getElementById('pinEntryAvatar').textContent = dn[0].toUpperCase();
        document.getElementById('pinEntryName').textContent = dn;
        document.getElementById('pinError').textContent = '';

        let boxesHtml = '';
        for (let i = 0; i < pinLength; i++) boxesHtml += '<div class="pin-box' + (i === 0 ? ' active' : '') + '" id="pinBox' + i + '"></div>';
        document.getElementById('pinBoxes').innerHTML = boxesHtml;

        const hi = document.getElementById('pinHiddenInput');
        hi.value = '';
        hi.maxLength = pinLength;
        setTimeout(function(){ hi.focus(); }, 100);
        document.getElementById('pinBoxes').onclick = function(){ hi.focus(); };
    }

    document.getElementById('pinHiddenInput').addEventListener('input', async function() {
        const val = this.value.replace(/\D/g, '').substring(0, pinLength);
        this.value = val;
        for (let i = 0; i < pinLength; i++) {
            const box = document.getElementById('pinBox' + i);
            if (!box) continue;
            box.textContent = i < val.length ? '\u25CF' : '';
            box.className = 'pin-box' + (i < val.length ? ' filled' : '') + (i === val.length ? ' active' : '');
        }
        if (val.length === pinLength && selectedFastUser) {
            document.getElementById('pinError').textContent = '';
            try {
                const res = await fetch(API + '/auth/fast-login', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: selectedFastUser.id, pin: val })
                });
                const data = await res.json();
                if (data.success) {
                    localStorage.setItem('token', data.data.token);
                    localStorage.setItem('user', JSON.stringify(data.data.user));
                    checkAuth();
                } else {
                    document.getElementById('pinError').textContent = data.error || 'Invalid PIN';
                    this.value = '';
                    for (let i = 0; i < pinLength; i++) {
                        const box = document.getElementById('pinBox' + i);
                        if (box) { box.textContent = ''; box.className = 'pin-box' + (i === 0 ? ' active' : ''); }
                    }
                }
            } catch {
                document.getElementById('pinError').textContent = 'Connection error';
                this.value = '';
            }
        }
    });

    document.getElementById('pinHiddenInput').addEventListener('keydown', function(e) {
        if (e.key === 'Escape') fastLoginShowUsers();
    });

    function fastLoginShowStandard() {
        document.getElementById('fastLoginOverlay').classList.remove('active');
        document.getElementById('loginModal').classList.add('active');
        if (selectedFastUser) {
            document.getElementById('loginUsername').value = selectedFastUser.username;
            document.getElementById('loginPassword').focus();
        }
    }

    // ──── Login Intro Video ────
    function playLoginIntro(wantMuted) {
        return new Promise(function(resolve) {
            const overlay = document.getElementById('introOverlay');
            const video = document.getElementById('introVideo');
            overlay.classList.add('active');
            video.playbackRate = 1.5;
            video.currentTime = 0;
            video.muted = !!wantMuted;

            function onEnded() {
                overlay.classList.add('fade-out');
                setTimeout(function() {
                    overlay.classList.remove('active', 'fade-out');
                    cleanup();
                    resolve(true);
                }, 800);
            }

            function onError() {
                overlay.classList.remove('active');
                cleanup();
                resolve(false);
            }

            function cleanup() {
                video.onended = null;
                video.onerror = null;
            }

            video.onended = onEnded;
            video.onerror = onError;

            video.play().catch(function() {
                // Autoplay with audio blocked — retry muted (browsers always allow muted autoplay)
                if (!video.muted) {
                    video.muted = true;
                    video.play().catch(function() {
                        // Even muted failed — skip
                        overlay.classList.remove('active');
                        cleanup();
                        resolve(false);
                    });
                } else {
                    overlay.classList.remove('active');
                    cleanup();
                    resolve(false);
                }
            });
        });
    }

    // ──── Setup Form ────
    document.getElementById('setupForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const msgDiv = document.getElementById('setupMessage');
        const body = {
            username: document.getElementById('setupUsername').value.trim(),
            first_name: document.getElementById('setupFirstName').value.trim(),
            last_name: document.getElementById('setupLastName').value.trim(),
            email: document.getElementById('setupEmail').value.trim(),
            password: document.getElementById('setupPassword').value,
            pin: document.getElementById('setupPin').value.trim()
        };
        try {
            const res = await fetch(API + '/setup', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            const data = await res.json();
            if (data.success) {
                localStorage.setItem('token', data.data.token);
                localStorage.setItem('user', JSON.stringify(data.data.user));
                document.getElementById('setupOverlay').classList.remove('active');
                checkAuth();
            } else {
                msgDiv.innerHTML = '<div class="message error">' + (data.error || 'Setup failed') + '</div>';
            }
        } catch {
            msgDiv.innerHTML = '<div class="message error">Connection error</div>';
        }
    });

    document.getElementById('loginForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const msgDiv = document.getElementById('authMessage');
        try {
            const data = await api('POST', '/auth/login', { username: document.getElementById('loginUsername').value, password: document.getElementById('loginPassword').value });
            if (data.success) { localStorage.setItem('token', data.data.token); localStorage.setItem('user', JSON.stringify(data.data.user)); checkAuth(); }
            else msgDiv.innerHTML='<div class="message error">'+(data.error||'Login failed')+'</div>';
        } catch { msgDiv.innerHTML='<div class="message error">Connection error</div>'; }
    });

    // ──── User Avatar Dropdown ────
    function doLogout() {
        localStorage.clear(); sessionStorage.removeItem('intro_played'); sessionStorage.removeItem('profile_picked'); currentUser=null;
        if(ws) ws.close();
        document.getElementById('fastLoginOverlay').classList.remove('active');
        document.getElementById('loginModal').classList.remove('active');
        closeHouseholdPicker();
        closeUserDropdown();
        checkAuth();
    }
    document.getElementById('udLogoutBtn').addEventListener('click', doLogout);

    document.getElementById('userAvatar').addEventListener('click', (e) => {
        e.stopPropagation();
        const dd = document.getElementById('userDropdown');
        if (dd.classList.contains('open')) { closeUserDropdown(); return; }
        // Populate dropdown header
        if (currentUser) {
            const nameEl = document.getElementById('udName');
            const fn = currentUser.first_name || '';
            const ln = currentUser.last_name || '';
            nameEl.textContent = (fn + ' ' + ln).trim() || currentUser.username;
            document.getElementById('udRole').textContent = currentUser.role;
            document.getElementById('udSettingsItem').style.display = currentUser.role === 'admin' ? '' : 'none';
            // Show Manage Profiles for master users (no parent_user_id)
            const isMaster = !currentUser.parent_user_id;
            document.getElementById('udManageProfilesItem').style.display = isMaster ? '' : 'none';
        }
        dd.classList.add('open');
    });

    function closeUserDropdown() {
        document.getElementById('userDropdown').classList.remove('open');
    }
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.user-menu')) closeUserDropdown();
    });

    // ──── Sidebar Libraries ────
    async function loadSidebarCounts() {
        try {
            const data = await api('GET', '/libraries');
            if (!data.success) return;
            allLibraries = data.data || [];
            const nav = document.getElementById('librariesNav');
            // Keep the label, rebuild items
            nav.innerHTML = '<div class="nav-label">Libraries</div>';
            for (const lib of allLibraries) {
                const icon = MEDIA_ICONS[lib.media_type] || '&#128218;';
                const item = document.createElement('div');
                item.className = 'nav-item nav-item-lib';
                item.dataset.view = 'library';
                item.dataset.id = lib.id;
                item.innerHTML = `<span class="nav-icon">${icon}</span><span class="nav-lib-info"><span class="nav-lib-name">${lib.name}</span><span class="nav-lib-count" id="badge-lib-${lib.id}"></span></span><span class="nav-lib-dots" data-lib-id="${lib.id}" title="Library options">&#8943;</span>`;
                item.querySelector('.nav-lib-info').addEventListener('click', () => navigate('library', lib.id));
                item.querySelector('.nav-icon').addEventListener('click', () => navigate('library', lib.id));
                const dotsBtn = item.querySelector('.nav-lib-dots');
                dotsBtn.addEventListener('click', (e) => { e.stopPropagation(); openLibCtxMenu(lib.id, dotsBtn); });
                nav.appendChild(item);
            }
            // Load counts
            for (const lib of allLibraries) {
                const countData = await api('GET', '/libraries/' + lib.id + '/media');
                if (countData.success) {
                    const badge = document.getElementById('badge-lib-' + lib.id);
                    if (badge) {
                        const total = countData.data.total || 0;
                        badge.textContent = total > 0 ? total.toLocaleString() + ' items' : '';
                    }
                }
            }
            // Load duplicate count badge
            try {
                const dupData = await api('GET', '/duplicates/count');
                if (dupData.success && dupData.data && dupData.data.count > 0) {
                    const dupBadge = document.getElementById('dupBadge');
                    if (dupBadge) { dupBadge.textContent = dupData.data.count; dupBadge.style.display = ''; }
                }
            } catch {}
            // Admin features moved to Settings page (Analytics under Content, Admin under Access)
        } catch {}
        // Load version footer
        loadSidebarVersion();
    }

    async function loadSidebarVersion() {
        try {
            const d = await api('GET', '/status');
            const ver = d.success && d.data ? d.data.version : '';
            const el = document.getElementById('sidebarFooter');
            if (el && ver) el.innerHTML = `<div class="sidebar-version">v${ver}</div><div class="sidebar-credit">Designed by 21 Mexican Jumping Llamas</div>`;
        } catch {}
    }

    // ──── Sidebar Library Context Menu ────
    function openLibCtxMenu(libId, dotsEl) {
        const menu = document.getElementById('libCtxMenu');
        const wasOpen = menu.classList.contains('open') && menu.dataset.libId === libId;
        closeLibCtxMenu();
        if (wasOpen) return;

        const isAdmin = currentUser && currentUser.role === 'admin';
        let html = '';
        if (isAdmin) html += `<div class="lib-ctx-item" onclick="showEditLibraryForm('${libId}')"><span class="ctx-icon">&#9998;</span> Edit Library</div><div class="lib-ctx-sep"></div>`;
        html += `<div class="lib-ctx-item" onclick="sidebarScanLibrary('${libId}')"><span class="ctx-icon">&#128269;</span> Scan Library</div>`;
        html += `<div class="lib-ctx-item" onclick="sidebarMetadataRefresh('${libId}')"><span class="ctx-icon">&#8635;</span> Metadata Refresh</div>`;
        html += `<div class="lib-ctx-item" onclick="sidebarRehashPhash('${libId}')"><span class="ctx-icon">&#128274;</span> Rehash pHash</div>`;
        menu.innerHTML = html;
        menu.dataset.libId = libId;

        // Position relative to the dots button
        const rect = dotsEl.getBoundingClientRect();
        menu.style.left = (rect.right - 4) + 'px';
        menu.style.top = rect.top + 'px';
        menu.classList.add('open');
        dotsEl.classList.add('active');

        // Adjust if menu goes off-screen bottom
        requestAnimationFrame(() => {
            const menuRect = menu.getBoundingClientRect();
            if (menuRect.bottom > window.innerHeight - 10) {
                menu.style.top = Math.max(10, window.innerHeight - menuRect.height - 10) + 'px';
            }
        });
    }
    function closeLibCtxMenu() {
        const menu = document.getElementById('libCtxMenu');
        menu.classList.remove('open');
        menu.dataset.libId = '';
        document.querySelectorAll('.nav-lib-dots.active').forEach(d => d.classList.remove('active'));
    }
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.nav-lib-dots') && !e.target.closest('.lib-ctx-menu')) closeLibCtxMenu();
    });

    function sidebarScanLibrary(libId) {
        closeLibCtxMenu();
        toast('Scan started...');
        api('POST', '/libraries/' + libId + '/scan').then(data => {
            if (data.success) {
                if (data.data.job_id) { /* progress via WebSocket */ }
                else { toast(`Scan: ${data.data.files_added} added, ${data.data.files_found} total`); loadSidebarCounts(); }
            } else toast('Scan failed: ' + (data.error || 'Unknown'), 'error');
        }).catch(e => toast('Scan error: ' + e.message, 'error'));
    }

    function sidebarMetadataRefresh(libId) {
        closeLibCtxMenu();
        const lib = allLibraries.find(l => l.id === libId);
        if (lib && !lib.retrieve_metadata) { toast('Metadata retrieval is disabled for this library', 'error'); return; }
        toast('Metadata refresh started — clearing & re-matching unlocked items...');
        api('POST', '/libraries/' + libId + '/refresh-metadata').then(data => {
            if (data.success) toast('Metadata refresh queued');
            else toast('Failed: ' + (data.error || 'Unknown'), 'error');
        }).catch(e => toast('Error: ' + e.message, 'error'));
    }

    function sidebarRehashPhash(libId) {
        closeLibCtxMenu();
        toast('pHash computation started...');
        api('POST', '/libraries/' + libId + '/phash').then(data => {
            if (data.success) toast('pHash job queued — duplicates will be analyzed');
            else toast('Failed: ' + (data.error || 'Unknown'), 'error');
        }).catch(e => toast('Error: ' + e.message, 'error'));
    }

    async function showEditLibraryForm(libId) {
        closeLibCtxMenu();
        const data = await api('GET', '/libraries/' + libId);
        if (!data.success) { toast('Failed to load library', 'error'); return; }
        const lib = data.data;
        const mc = document.getElementById('mainContent');
        const types = Object.entries(MEDIA_LABELS).map(([k,v])=>`<option value="${k}" ${k===lib.media_type?'selected':''}>${v}</option>`).join('');
        const folders = (lib.folders && lib.folders.length > 0) ? lib.folders : [{ folder_path: lib.path }];
        const folderRows = folders.map((f, i) => `<div class="folder-row" data-idx="${i}">
            <input type="text" class="lib-folder-input" placeholder="/media/folder" style="flex:1;" value="${f.folder_path || ''}">
            <button class="btn-secondary" onclick="openFolderBrowser(${i})" style="white-space:nowrap;padding:8px 12px;font-size:0.8rem;">&#128193; Browse</button>
            ${i > 0 ? '<button class="folder-remove" onclick="removeFolderRow(this)" title="Remove folder">&#10005;</button>' : ''}
        </div>`).join('');

        mc.innerHTML = `<div class="section-header"><h2 class="section-title">Edit Library</h2></div>
        <div style="max-width:560px;">
            <input type="hidden" id="editLibId" value="${lib.id}">
            <div class="form-group"><label>Name</label><input type="text" id="libName" value="${lib.name}"></div>
            <div class="form-group"><label>Media Type</label><select id="libType" disabled>${types}</select>
                <p style="color:#5a6a7f;font-size:0.75rem;margin-top:4px;">Media type cannot be changed after creation</p>
            </div>

            <div class="form-group">
                <label>Folders</label>
                <p style="color:#8a9bae;font-size:0.78rem;margin-bottom:8px;">At least one folder is required. Add more to scan multiple locations.</p>
                <div class="folder-list" id="folderList">${folderRows}</div>
                <button class="folder-add-btn" onclick="addFolderRow()">+ Add Folder</button>
            </div>
            <div id="pathBrowser" style="display:none;margin-bottom:18px;background:rgba(0,0,0,0.3);border:1px solid rgba(0,217,255,0.15);border-radius:12px;padding:14px;max-height:350px;overflow-y:auto;"></div>

            <div id="seasonGroupingOpt" style="${lib.media_type === 'tv_shows' ? '' : 'display:none;'}">
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">Group by Season</div>
                        <div class="option-row-desc">Parse SxxExx from filenames to group episodes by season</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="seasonGrouping" value="yes" ${lib.season_grouping?'checked':''}><span>Yes</span></label>
                        <label><input type="radio" name="seasonGrouping" value="no" ${!lib.season_grouping?'checked':''}><span>No</span></label>
                    </div>
                </div>
            </div>

            <div id="adultContentOpt" style="${lib.media_type === 'adult_movies' ? '' : 'display:none;'}">
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">Content Type</div>
                        <div class="option-row-desc">Clips &amp; Scenes will not retrieve metadata. Movies will scrape from TMDB.</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="adultContentType" value="movies" ${(!lib.adult_content_type || lib.adult_content_type === 'movies')?'checked':''}><span>Movies</span></label>
                        <label><input type="radio" name="adultContentType" value="clips" ${lib.adult_content_type === 'clips'?'checked':''}><span>Clips</span></label>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label>Library Permissions</label>
                <select id="libAccess" onchange="onAccessChange()">
                    <option value="everyone" ${lib.access_level==='everyone'?'selected':''}>Everyone</option>
                    <option value="select_users" ${lib.access_level==='select_users'?'selected':''}>Select People</option>
                    <option value="admin_only" ${lib.access_level==='admin_only'?'selected':''}>Admin Only</option>
                </select>
            </div>
            <div id="userSelectPanel" style="${lib.access_level==='select_users'?'':'display:none;'}margin-bottom:18px;background:rgba(0,0,0,0.3);border:1px solid rgba(0,217,255,0.15);border-radius:12px;padding:14px;">
                <p style="color:#8a9bae;font-size:0.8rem;margin-bottom:10px;">Select users who can access this library:</p>
                <div id="userCheckboxList"><div class="spinner"></div></div>
            </div>

            <div style="margin-bottom:18px;">
                <label style="display:block;margin-bottom:10px;font-weight:600;color:#e5e5e5;">Library Options</label>
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">Include in Homepage</div>
                        <div class="option-row-desc">Show this library's media on the home screen</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="includeHomepage" value="yes" ${lib.include_in_homepage?'checked':''}><span>Yes</span></label>
                        <label><input type="radio" name="includeHomepage" value="no" ${!lib.include_in_homepage?'checked':''}><span>No</span></label>
                    </div>
                </div>
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">Include in Search</div>
                        <div class="option-row-desc">Allow this library's items to appear in search results</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="includeSearch" value="yes" ${lib.include_in_search?'checked':''}><span>Yes</span></label>
                        <label><input type="radio" name="includeSearch" value="no" ${!lib.include_in_search?'checked':''}><span>No</span></label>
                    </div>
                </div>
                <div class="option-row" id="metadataOpt">
                    <div class="option-row-info">
                        <div class="option-row-label">Retrieve Metadata</div>
                        <div class="option-row-desc">Auto-populate from TMDB/MusicBrainz/OpenLibrary on scan</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="retrieveMetadata" value="yes" ${lib.retrieve_metadata?'checked':''}><span>Yes</span></label>
                        <label><input type="radio" name="retrieveMetadata" value="no" ${!lib.retrieve_metadata?'checked':''}><span>No</span></label>
                    </div>
                </div>
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">NFO Import</div>
                        <div class="option-row-desc">Read Kodi/Jellyfin .nfo sidecar files for metadata &amp; provider IDs</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="nfoImport" value="yes" ${lib.nfo_import?'checked':''}><span>Yes</span></label>
                        <label><input type="radio" name="nfoImport" value="no" ${!lib.nfo_import?'checked':''}><span>No</span></label>
                    </div>
                </div>
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">NFO Export</div>
                        <div class="option-row-desc">Write .nfo sidecar files after metadata is populated</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="nfoExport" value="yes" ${lib.nfo_export?'checked':''}><span>Yes</span></label>
                        <label><input type="radio" name="nfoExport" value="no" ${!lib.nfo_export?'checked':''}><span>No</span></label>
                    </div>
                </div>
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">Prefer Local Artwork</div>
                        <div class="option-row-desc">Use poster/backdrop/logo files found next to media before fetching remote</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="preferLocalArtwork" value="yes" ${lib.prefer_local_artwork!==false?'checked':''}><span>Yes</span></label>
                        <label><input type="radio" name="preferLocalArtwork" value="no" ${lib.prefer_local_artwork===false?'checked':''}><span>No</span></label>
                    </div>
                </div>
            </div>

            <button class="btn-primary" onclick="saveEditLibrary()">Save Changes</button>
            <button class="btn-secondary" style="margin-left:12px;" onclick="loadLibrariesView()">Cancel</button>
        </div>`;

        // Load user checkboxes if select_users
        if (lib.access_level === 'select_users') {
            const usersData = await api('GET', '/users');
            const list = document.getElementById('userCheckboxList');
            const allowed = lib.allowed_users ? lib.allowed_users.map(u => u.toString()) : [];
            if (usersData.success && usersData.data && usersData.data.length > 0) {
                list.innerHTML = usersData.data.filter(u => u.role !== 'admin').map(u =>
                    `<label style="display:flex;align-items:center;gap:8px;padding:6px 0;cursor:pointer;color:#e5e5e5;">
                        <input type="checkbox" class="user-perm-cb" value="${u.id}" ${allowed.includes(u.id)?'checked':''}>
                        <span>${u.username}</span>
                        <span style="color:#5a6a7f;font-size:0.75rem;margin-left:auto;">${u.role}</span>
                    </label>`
                ).join('');
                if (list.innerHTML === '') list.innerHTML = '<p style="color:#5a6a7f;font-size:0.85rem;">No non-admin users found</p>';
            }
        }
    }

    async function saveEditLibrary() {
        const id = document.getElementById('editLibId').value;
        const name = document.getElementById('libName').value;
        const media_type = document.getElementById('libType').value;
        const folderInputs = document.querySelectorAll('.lib-folder-input');
        const folders = [...folderInputs].map(i => i.value.trim()).filter(Boolean);
        if (!name || folders.length === 0) { toast('Name and at least one folder required', 'error'); return; }

        const season_grouping = media_type === 'tv_shows' && document.querySelector('input[name="seasonGrouping"]:checked')?.value === 'yes';
        const access_level = document.getElementById('libAccess').value;
        const allowed_users = [...document.querySelectorAll('.user-perm-cb:checked')].map(cb => cb.value);
        const include_in_homepage = document.querySelector('input[name="includeHomepage"]:checked')?.value === 'yes';
        const include_in_search = document.querySelector('input[name="includeSearch"]:checked')?.value === 'yes';
        const retrieve_metadata = document.querySelector('input[name="retrieveMetadata"]:checked')?.value === 'yes';
        const nfo_import = document.querySelector('input[name="nfoImport"]:checked')?.value === 'yes';
        const nfo_export = document.querySelector('input[name="nfoExport"]:checked')?.value === 'yes';
        const prefer_local_artwork = document.querySelector('input[name="preferLocalArtwork"]:checked')?.value === 'yes';

        let adult_content_type = null;
        if (media_type === 'adult_movies') {
            adult_content_type = document.querySelector('input[name="adultContentType"]:checked')?.value || 'movies';
        }

        const d = await api('PUT', '/libraries/' + id, {
            name, path: folders[0], folders, is_enabled: true,
            season_grouping, access_level, allowed_users,
            include_in_homepage, include_in_search, retrieve_metadata,
            nfo_import, nfo_export, prefer_local_artwork, adult_content_type
        });
        if (d.success) { toast('Library updated!'); loadLibrariesView(); loadSidebarCounts(); }
        else toast('Failed: ' + d.error, 'error');
    }

    // ──── Navigation ────
    function navigate(view, extra) {
        selectionState.clear();
        closeUserDropdown();
        document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
        if (view === 'library' && extra) {
            const navItem = document.querySelector(`.nav-item[data-view="library"][data-id="${extra}"]`);
            if (navItem) navItem.classList.add('active');
        } else {
            const navItem = document.querySelector(`.nav-item[data-view="${view}"]`);
            if (navItem) navItem.classList.add('active');
        }
        switch(view) {
            case 'home': loadHomeView(); break;
            case 'libraries': loadLibrariesView(); break;
            case 'library': loadLibraryView(extra); break;
            case 'media': loadMediaTypeView(extra); break;
            case 'collections': loadCollectionsView(); break;
            case 'collection': loadCollectionDetailView(extra); break;
            case 'performers': loadPerformersView(); break;
            case 'tags': loadTagsView(); break;
            case 'studios': loadStudiosView(); break;
            case 'duplicates': loadDuplicatesView(); break;
            case 'settings': window.location.href = 'settings.html'; break;
            case 'admin': window.location.href = 'settings.html#admin'; break;
            case 'analytics': window.location.href = 'settings.html#analytics'; break;
            case 'profile': loadProfileView(); break;
        }
    }

    document.querySelectorAll('.nav-item[data-view]').forEach(item => {
        item.addEventListener('click', () => navigate(item.dataset.view, item.dataset.type));
    });

    let searchTimeout;
    document.getElementById('searchInput').addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { if (e.target.value.length >= 2) loadSearchView(e.target.value); }, 400);
    });

    // ──── Overlay Badge Helpers ────
    const AUDIO_LABEL_MAP = {
        'truehd atmos': 'Atmos', 'truehd_atmos': 'Atmos', 'eac3 atmos': 'Atmos', 'eac3_atmos': 'Atmos',
        'dolby atmos': 'Atmos', 'atmos': 'Atmos',
        'truehd': 'TrueHD', 'dts-hd ma': 'DTS-HD MA', 'dts-hd': 'DTS-HD', 'dtshd': 'DTS-HD',
        'dts-x': 'DTS:X', 'dtsx': 'DTS:X', 'dts:x': 'DTS:X',
        'dts': 'DTS', 'eac3': 'EAC3', 'ac3': 'AC3', 'aac': 'AAC',
        'flac': 'FLAC', 'pcm': 'PCM', 'opus': 'Opus', 'vorbis': 'Vorbis', 'mp3': 'MP3',
        'pcm_s16le': 'PCM', 'pcm_s24le': 'PCM', 'pcm_s32le': 'PCM',
    };
    const EDITION_LABEL_MAP = {
        'directors_cut': "Director's Cut", 'directors cut': "Director's Cut",
        'extended': 'Extended', 'theatrical': 'Theatrical', 'unrated': 'Unrated',
        'imax': 'IMAX', 'remastered': 'Remastered', 'criterion': 'Criterion',
        'uncut': 'Uncut', 'special': 'Special', '3d': '3D',
    };
    const SOURCE_LABEL_MAP = {
        'remux': 'REMUX', 'bluray': 'Blu-Ray', 'blu-ray': 'Blu-Ray',
        'web-dl': 'WEB-DL', 'webdl': 'WEB-DL', 'webrip': 'WEBRip', 'web': 'WEB',
        'hdtv': 'HDTV', 'dvd': 'DVD', 'dvdrip': 'DVDRip', 'bdrip': 'BDRip',
        'brrip': 'BRRip', 'sdtv': 'SDTV', 'cam': 'CAM',
    };

    function buildResolutionLabel(item) {
        let res = (item.resolution || '').toUpperCase();
        if (!res) return '';
        // Normalize common forms
        if (res === '2160P' || res === '2160' || res === 'UHD') res = '4K';
        const hdr = item.hdr_format || item.dynamic_range || '';
        if (!hdr || hdr === 'SDR' || hdr === 'sdr') return res;
        const hdrUpper = hdr.toUpperCase();
        if (hdrUpper.includes('DOLBY VISION') || hdrUpper === 'DV' || hdrUpper.includes('DOLBY_VISION')) return res + ' DV';
        if (hdrUpper.includes('HDR10+') || hdrUpper === 'HDR10PLUS') return res + ' HDR10+';
        if (hdrUpper.includes('HDR10') || hdrUpper.includes('HDR')) return res + ' HDR';
        if (hdrUpper.includes('HLG')) return res + ' HLG';
        return res + ' ' + hdr;
    }

    function mapAudioLabel(item) {
        const raw = (item.audio_codec || '').toLowerCase().trim();
        if (!raw) return '';
        // Try exact match first, then partial
        if (AUDIO_LABEL_MAP[raw]) return AUDIO_LABEL_MAP[raw];
        for (const [key, label] of Object.entries(AUDIO_LABEL_MAP)) {
            if (raw.includes(key)) return label;
        }
        // Append channel info if available
        const base = raw.toUpperCase();
        if (item.audio_channels && item.audio_channels > 2) return base + ' ' + item.audio_channels + '.1';
        return base;
    }

    function mapEditionLabel(item) {
        const raw = (item.edition_type || '').toLowerCase().trim();
        if (!raw || raw === 'standard' || raw === 'unknown') return '';
        if (EDITION_LABEL_MAP[raw]) return EDITION_LABEL_MAP[raw];
        // Try partial match
        for (const [key, label] of Object.entries(EDITION_LABEL_MAP)) {
            if (raw.includes(key)) return label;
        }
        // Capitalize first letter as fallback
        return raw.charAt(0).toUpperCase() + raw.slice(1);
    }

    function mapSourceLabel(item) {
        const raw = (item.source_type || '').toLowerCase().trim();
        if (!raw) return '';
        if (SOURCE_LABEL_MAP[raw]) return SOURCE_LABEL_MAP[raw];
        for (const [key, label] of Object.entries(SOURCE_LABEL_MAP)) {
            if (raw.includes(key)) return label;
        }
        return raw.toUpperCase();
    }

    function renderOverlayBadges(item) {
        const p = overlayPrefs;
        let trBadges = '', tlBadges = '', blBadges = '', brBadges = '';

        // TOP-RIGHT: Resolution + HDR, Audio Codec
        if (p.resolution_hdr) {
            const resLabel = buildResolutionLabel(item);
            if (resLabel) {
                const isHDR = resLabel.includes('HDR') || resLabel.includes('DV') || resLabel.includes('HLG');
                trBadges += `<span class="overlay-badge ${isHDR ? 'overlay-badge-res-hdr' : 'overlay-badge-res'}">${resLabel}</span>`;
            }
        }
        if (p.audio_codec) {
            const audioLabel = mapAudioLabel(item);
            if (audioLabel) trBadges += `<span class="overlay-badge overlay-badge-audio">${audioLabel}</span>`;
        }

        // TOP-LEFT: Content Rating + Edition Type (single row)
        if (p.content_rating && item.content_rating) {
            tlBadges += `<span class="overlay-badge overlay-badge-content-rating">${item.content_rating}</span>`;
        }
        if (p.edition_type) {
            if (item.edition_count && item.edition_count > 1) {
                // Multiple editions: only show count badge, skip individual edition label
                tlBadges += `<span class="overlay-badge overlay-badge-edition">${item.edition_count} Editions</span>`;
            } else {
                const edLabel = mapEditionLabel(item);
                if (edLabel) tlBadges += `<span class="overlay-badge overlay-badge-edition">${edLabel}</span>`;
            }
        }

        // BOTTOM-LEFT: Ratings
        if (p.ratings) {
            if (item.imdb_rating) blBadges += `<span class="overlay-badge overlay-badge-imdb">IMDb ${item.imdb_rating.toFixed(1)}</span>`;
            if (item.rt_rating) blBadges += `<span class="overlay-badge overlay-badge-rt">RT ${item.rt_rating}%</span>`;
            if (item.audience_score) blBadges += `<span class="overlay-badge overlay-badge-tmdb">AS ${item.audience_score}%</span>`;
        }

        // BOTTOM-RIGHT: Source Type
        if (p.source_type) {
            const srcLabel = mapSourceLabel(item);
            if (srcLabel) brBadges += `<span class="overlay-badge overlay-badge-source">${srcLabel}</span>`;
        }

        let html = '';
        if (trBadges) html += `<div class="overlay-zone-tr">${trBadges}</div>`;
        if (tlBadges) html += `<div class="overlay-zone-tl">${tlBadges}</div>`;
        if (blBadges) html += `<div class="overlay-zone-bl">${blBadges}</div>`;
        if (brBadges) html += `<div class="overlay-zone-br">${brBadges}</div>`;
        return html;
    }

    // ──── Media Card (with expanded hover info) ────
    function renderMediaCard(item) {
        const dur = item.duration_seconds ? Math.floor(item.duration_seconds/60)+'min' : '';
        const year = item.year || '';
        const res = item.resolution || '';
        const meta = [year, dur, res].filter(Boolean).join(' \u00b7 ');
        // Hover info extras
        const hoverMeta = [year, res, item.codec].filter(Boolean).join(' \u00b7 ');
        const ratingBadge = item.rating ? `<span class="hover-rating-badge">&#11088; ${item.rating.toFixed(1)}</span>` : '';
        const isSelected = selectionState.selectedIds.has(item.id);
        const sortAttr = item.sort_title ? ' data-sort-title="'+item.sort_title.replace(/"/g,'&amp;quot;')+'"' : '';
        return `<div class="media-card${isSelected ? ' selected' : ''}" tabindex="0" data-media-id="${item.id}"${sortAttr} onclick="handleCardClick('${item.id}', event)">
            <div class="media-poster" style="position:relative;">
                <div class="select-checkbox" onclick="handleCheckboxClick('${item.id}', event)">
                    <svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>
                </div>
                ${item.poster_path ? '<img src="'+posterSrc(item.poster_path, item.updated_at)+'" alt="" loading="lazy">' : mediaIcon(item.media_type)}
                ${renderOverlayBadges(item)}
                <div class="media-card-hover-info">
                    <div class="hover-title">${item.title}</div>
                    <div class="hover-meta">${ratingBadge}<span>${hoverMeta}</span></div>
                </div>
                <div class="play-overlay"><div class="play-button">&#9654;</div></div>
            </div>
            <div class="media-info"><div class="media-title">${item.title}</div><div class="media-meta">${meta}</div></div>
        </div>`;
    }

    // ──── Skeleton Generators ────
    function skeletonCards(count) {
        return Array(count).fill('').map(() => `<div class="skeleton-card"><div class="skeleton skeleton-poster"></div><div class="skeleton skeleton-title"></div><div class="skeleton skeleton-meta"></div></div>`).join('');
    }

    // ──── Home View (with Hero Banner + Skeleton Loading) ────
    async function loadHomeView() {
        const mc = document.getElementById('mainContent');
        // Show skeleton layout immediately
        mc.innerHTML = `
            <div class="skeleton skeleton-hero"></div>
            <div class="section-header"><h2 class="section-title">Continue Watching</h2></div>
            <div id="continueRow" class="continue-row skeleton-row">${skeletonCards(6)}</div>
            <div class="section-header"><h2 class="section-title">Recently Added</h2></div>
            <div class="media-grid" id="recentGrid">${skeletonCards(12)}</div>`;

        // Fetch all data concurrently
        const [cwResult, libsResult] = await Promise.allSettled([
            api('GET', '/watch/continue'),
            api('GET', '/libraries')
        ]);

        // Build hero banner + recently added from libraries
        let allItems = [];
        try {
            const libs = libsResult.status === 'fulfilled' ? libsResult.value : { success: false };
            if (libs.success && libs.data) {
                const homepageLibs = libs.data.filter(lib => lib.include_in_homepage !== false);
                const mediaPromises = homepageLibs.slice(0,5).map(lib => api('GET', '/libraries/'+lib.id+'/media'));
                const mediaResults = await Promise.allSettled(mediaPromises);
                for (const r of mediaResults) {
                    if (r.status === 'fulfilled' && r.value.success && r.value.data && r.value.data.items)
                        allItems = allItems.concat(r.value.data.items);
                }
                allItems.sort((a,b) => new Date(b.added_at) - new Date(a.added_at));
            }
        } catch {}

        // Pick a hero item (random from top recently added items with posters)
        const heroPool = allItems.filter(i => i.poster_path).slice(0, 20);
        const heroItem = heroPool.length > 0 ? heroPool[Math.floor(Math.random() * Math.min(heroPool.length, 8))] : null;

        // Build hero banner HTML
        let heroHTML = '';
        if (heroItem) {
            const hMeta = [heroItem.year, heroItem.resolution, heroItem.codec].filter(Boolean).join(' \u00b7 ');
            const hDesc = heroItem.description ? heroItem.description.substring(0, 200) + (heroItem.description.length > 200 ? '...' : '') : '';
            heroHTML = `<div class="hero-banner">
                <div class="hero-banner-bg" style="background-image:url('${posterSrc(heroItem.poster_path, heroItem.updated_at)}')"></div>
                <div class="hero-banner-gradient"></div>
                <div class="hero-banner-content">
                    <div class="hero-banner-title">${heroItem.title}</div>
                    <div class="hero-banner-meta">
                        ${heroItem.rating ? '<span class="hero-rating">&#11088; '+heroItem.rating.toFixed(1)+'</span>' : ''}
                        <span>${hMeta}</span>
                    </div>
                    ${hDesc ? '<div class="hero-banner-desc">'+hDesc+'</div>' : ''}
                    <div class="hero-banner-actions">
                        <button class="hero-btn-play" onclick="playMedia('${heroItem.id}','${(heroItem.title||'').replace(/'/g,"\\'")}')">&#9654; Play</button>
                        <button class="hero-btn-info" onclick="loadMediaDetail('${heroItem.id}')">&#9432; More Info</button>
                    </div>
                </div>
            </div>`;
        }

        // Build continue watching with enhanced info
        let cwHTML = '';
        try {
            const cw = cwResult.status === 'fulfilled' ? cwResult.value : { success: false };
            if (cw.success && cw.data && cw.data.length > 0) {
                cwHTML = cw.data.map(wh => {
                    const item = wh.media_item || {};
                    const pct = wh.duration_seconds ? Math.round(wh.progress_seconds/wh.duration_seconds*100) : 0;
                    const remainSec = wh.duration_seconds ? wh.duration_seconds - wh.progress_seconds : 0;
                    const remainMin = Math.ceil(remainSec / 60);
                    const timeLeft = remainMin > 0 ? remainMin + ' min left' : '';
                    return `<div class="media-card" tabindex="0" onclick="playMedia('${item.id}','${(item.title||'').replace(/'/g,"\\'")}')">
                        <div class="media-poster" style="position:relative;">
                            ${item.poster_path ? '<img src="'+posterSrc(item.poster_path, item.updated_at)+'">' : mediaIcon(item.media_type||'movies')}
                            ${renderOverlayBadges(item)}
                            <div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>
                            ${timeLeft ? '<span class="cw-time-left">'+timeLeft+'</span>' : ''}
                            <button class="cw-remove" onclick="event.stopPropagation();removeContinue('${item.id}')" title="Remove">&#10005;</button>
                            <div class="play-overlay"><div class="play-button">&#9654;</div></div>
                        </div>
                        <div class="media-info"><div class="media-title">${item.title||'Unknown'}</div><div class="media-meta">${Math.floor(wh.progress_seconds/60)}/${wh.duration_seconds?Math.floor(wh.duration_seconds/60):'?'} min</div></div>
                    </div>`;
                }).join('');
            } else cwHTML = '<div style="color:#5a6a7f;padding:20px;">No items in progress</div>';
        } catch { cwHTML = ''; }

        // Build recently added grid
        let recentHTML = '';
        if (allItems.length > 0) {
            recentHTML = allItems.slice(0,12).map(renderMediaCard).join('');
        } else {
            recentHTML = `<div class="empty-state" style="grid-column:1/-1;"><div class="empty-state-icon">&#128253;</div><div class="empty-state-title">No media yet</div><p>Add libraries and scan them to populate your media</p><button class="btn-primary" style="margin-top:18px;" onclick="navigate('libraries')">Manage Libraries</button></div>`;
        }

        // Render everything at once (no flicker)
        mc.innerHTML = `
            ${heroHTML}
            <div class="section-header"><h2 class="section-title">Continue Watching</h2></div>
            <div id="continueRow" class="continue-row">${cwHTML}</div>
            <div class="section-header"><h2 class="section-title">Recently Added</h2></div>
            <div class="media-grid" id="recentGrid">${recentHTML}</div>`;

        // Enable keyboard nav on the new grid
        enableGridKeyNav(document.getElementById('recentGrid'));
    }

    // ──── Remove from Continue Watching ────
    async function removeContinue(mediaId) {
        const d = await api('DELETE', '/watch/continue/' + mediaId);
        if (d.success) { toast('Removed from Continue Watching'); loadHomeView(); }
        else toast(d.error || 'Failed to remove', 'error');
    }

    // ──── Media Detail ────
    var _detailMediaId = null;

    async function loadMediaDetail(id) {
        _detailMediaId = id;
        const mc = document.getElementById('mainContent');
        mc.innerHTML = '<div class="spinner"></div> Loading...';
        const data = await api('GET', '/media/' + id);
        if (!data.success) { mc.innerHTML = '<div class="empty-state"><div class="empty-state-title">Media not found</div></div>'; return; }
        const m = data.data;
        const dur = m.duration_seconds ? formatDuration(m.duration_seconds) : '';
        const hdrTag = m.dynamic_range === 'HDR' ? (m.hdr_format || 'HDR') : '';
        const meta = [m.year, dur, m.resolution, m.codec, m.source_type, hdrTag].filter(Boolean).join(' \u00b7 ');

        // Build ratings row
        let ratingsHTML = '';
        const hasAnyRating = m.rating || m.imdb_rating || m.rt_rating != null || m.audience_score != null;
        if (hasAnyRating) {
            ratingsHTML = '<div class="ratings-row">';
            if (m.rating) ratingsHTML += `<div class="rating-badge rating-tmdb"><span class="rating-icon">&#11088;</span><span class="rating-value">${m.rating.toFixed(1)}</span><span class="rating-label">TMDB</span></div>`;
            if (m.imdb_rating) ratingsHTML += `<div class="rating-badge rating-imdb"><span class="rating-icon">&#127902;</span><span class="rating-value">${m.imdb_rating.toFixed(1)}</span><span class="rating-label">IMDb</span></div>`;
            if (m.rt_rating != null) ratingsHTML += `<div class="rating-badge rating-rt"><span class="rating-icon">&#127813;</span><span class="rating-value">${m.rt_rating}%</span><span class="rating-label">Rotten Tomatoes</span></div>`;
            if (m.audience_score != null) ratingsHTML += `<div class="rating-badge rating-audience"><span class="rating-icon">&#128101;</span><span class="rating-value">${m.audience_score}%</span><span class="rating-label">Audience</span></div>`;
            ratingsHTML += '</div>';
        }

        mc.innerHTML = `
            <div class="detail-hero">
                <div class="detail-poster">${m.poster_path ? '<img src="'+posterSrc(m.poster_path, m.updated_at)+'">' : mediaIcon(m.media_type)}</div>
                <div class="detail-info">
                    <h1>${m.title}</h1>
                    <div class="meta-row">${meta}</div>
                    ${m.description ? '<p class="description">'+m.description+'</p>' : ''}
                    <div id="detailGenreTags" class="genre-tags"></div>
                    ${ratingsHTML}
                    <div class="detail-actions">
                        <button class="btn-primary" onclick="playMedia('${m.id}','${m.title.replace(/'/g,"\\'")}')">&#9654; Play</button>
                        <button class="btn-secondary" onclick="playDirect('${m.id}','${m.title.replace(/'/g,"\\'")}')">&#128190; Direct Play</button>
                        <button class="btn-secondary" onclick="openEditModal('${m.id}')">&#9998; Edit</button>
                        <button class="btn-secondary" onclick="identifyMedia('${m.id}')">&#128270; Identify</button>
                        <button class="btn-secondary" onclick="showAddToCollectionPicker('${m.id}')">&#128218; + Collection</button>
                    </div>
                    <div style="margin-bottom:10px;">
                        ${m.metadata_locked ? '<span class="lock-badge locked">&#128274; Metadata Locked</span>' : ''}
                        <span class="tag tag-cyan">${MEDIA_LABELS[m.media_type]||m.media_type}</span>
                        ${m.edition_count > 1 ? '<span class="tag" style="background:rgba(168,85,247,0.3);color:#d4a5ff;">Multiple Editions</span>' : ''}
                        ${m.file_size ? '<span class="tag tag-purple">'+(m.file_size/1024/1024).toFixed(0)+' MB</span>' : ''}
                        ${m.source_type ? '<span class="tag tag-blue">'+m.source_type.toUpperCase()+'</span>' : ''}
                        ${m.dynamic_range === 'HDR' ? '<span class="tag tag-gold">'+(m.hdr_format || 'HDR')+'</span>' : ''}
                        ${m.audio_codec ? '<span class="tag tag-green">'+m.audio_codec+'</span>' : ''}
                        ${m.bitrate ? '<span class="tag tag-orange">'+(m.bitrate/1000).toFixed(0)+' kbps</span>' : ''}
                    </div>
                    <div class="detail-tabs">
                        <button class="detail-tab active" onclick="showDetailTab(this,'info','${m.id}')">Info</button>
                        <button class="detail-tab" onclick="showDetailTab(this,'cast','${m.id}')">Cast</button>
                        <button class="detail-tab" onclick="showDetailTab(this,'tags-tab','${m.id}')">Tags</button>
                        ${m.edition_count > 1 ? '<button class="detail-tab" onclick="showDetailTab(this,\'editions\',\''+m.id+'\')">Editions</button>' : ''}
                        <button class="detail-tab" onclick="showDetailTab(this,'metadata','${m.id}')">Metadata</button>
                        <button class="detail-tab" onclick="showDetailTab(this,'segments','${m.id}')">Segments</button>
                        <button class="detail-tab" onclick="showDetailTab(this,'file','${m.id}')">File</button>
                    </div>
                    <div class="detail-tab-content" id="detailTabContent">
                        <table style="width:100%;font-size:0.85rem;">
                            <tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">File</td><td>${m.file_name}</td></tr>
                            <tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Path</td><td style="word-break:break-all;">${m.file_path}</td></tr>
                            ${m.width ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Resolution</td><td>'+m.width+'x'+m.height+'</td></tr>' : ''}
                            ${m.codec ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Video Codec</td><td>'+m.codec+'</td></tr>' : ''}
                            ${m.source_type ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Source</td><td>'+m.source_type+'</td></tr>' : ''}
                            ${m.dynamic_range && m.dynamic_range !== 'SDR' ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Dynamic Range</td><td>'+m.dynamic_range+(m.hdr_format ? ' ('+m.hdr_format+')' : '')+'</td></tr>' : ''}
                            ${m.custom_notes ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Notes</td><td>'+m.custom_notes+'</td></tr>' : ''}
                            <tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Added</td><td>${new Date(m.added_at).toLocaleString()}</td></tr>
                        </table>
                    </div>
                </div>
            </div>
            <button class="btn-secondary" onclick="navigate('home')">&#8592; Back</button>`;

        // Load genre tags for this item
        loadMediaGenreTags(id);
    }

    async function loadMediaGenreTags(mediaId) {
        const tagData = await api('GET', '/media/' + mediaId + '/tags');
        const container = document.getElementById('detailGenreTags');
        if (!container) return;
        if (tagData.success && tagData.data && tagData.data.length > 0) {
            const genreTags = tagData.data.filter(t => t.category === 'genre');
            const moodTags = tagData.data.filter(t => t.category === 'mood');
            let html = '';
            if (genreTags.length > 0) {
                html += genreTags.map(t => `<span class="genre-tag">${t.name}</span>`).join('');
            }
            if (moodTags.length > 0) {
                html += moodTags.map(t => `<span class="genre-tag mood-tag">${t.name}</span>`).join('');
            }
            container.innerHTML = html;
        }
    }

    async function showDetailTab(btn, tab, mediaId) {
        btn.parentElement.querySelectorAll('.detail-tab').forEach(t => t.classList.remove('active'));
        btn.classList.add('active');
        const tc = document.getElementById('detailTabContent');
        if (!tc) return;
        if (tab === 'tags-tab') {
            tc.innerHTML = '<div class="spinner"></div>';
            // Fetch tags for this media item
            const res = await api('GET', '/media/' + mediaId + '/tags');
            if (res.success && res.data && res.data.length > 0) {
                tc.innerHTML = '<div class="genre-tags">' + res.data.map(t =>
                    `<span class="genre-tag">${t.name}</span>`
                ).join('') + '</div>';
            } else {
                tc.innerHTML = '<p style="color:#5a6a7f;">No tags assigned</p>';
            }
        } else if (tab === 'info') {
            loadMediaDetail(mediaId);
        } else if (tab === 'cast') {
            tc.innerHTML = '<div class="spinner"></div>';
            const castRes = await api('GET', '/media/' + mediaId + '/cast');
            if (castRes.success && castRes.data && castRes.data.length > 0) {
                const all = castRes.data.map(c => {
                    const subtitle = c.role === 'actor' ? (c.character_name || '') : c.role;
                    return `<div class="cast-card" onclick="loadPerformerDetail('${c.performer_id}')"><div class="person-avatar">${c.photo_path ? '<img src="'+c.photo_path+'">' : '&#128100;'}</div><div class="person-name">${c.name}</div><div class="person-role">${subtitle}</div></div>`;
                }).join('');
                tc.innerHTML = `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:14px;"><h4 style="color:#e5e5e5;margin:0;">Cast &amp; Crew</h4></div><div class="cast-row"><button class="cast-row-arrow left" onclick="document.getElementById('castScroll').scrollLeft-=400">&#8249;</button><div class="cast-row-scroll" id="castScroll">${all}</div><button class="cast-row-arrow right" onclick="document.getElementById('castScroll').scrollLeft+=400">&#8250;</button></div>`;
            } else {
                tc.innerHTML = '<p style="color:#5a6a7f;">No cast information available</p>';
            }
        } else if (tab === 'editions') {
            tc.innerHTML = '<div class="spinner"></div>';
            const edRes = await api('GET', '/media/' + mediaId + '/editions');
            if (edRes.success && edRes.data.has_editions && edRes.data.editions && edRes.data.editions.length > 0) {
                const eds = edRes.data.editions;
                const rows = eds.map(e => {
                    const dur = e.duration_seconds ? formatDuration(e.duration_seconds) : '-';
                    const res = e.resolution || '-';
                    const codec = e.codec || '-';
                    const size = e.file_size ? (e.file_size/1024/1024).toFixed(0)+' MB' : '-';
                    const audio = e.audio_codec || '-';
                    const src = e.source_type || '-';
                    const dr = e.dynamic_range === 'HDR' ? (e.hdr_format || 'HDR') : (e.dynamic_range || 'SDR');
                    const defBadge = e.is_default ? ' <span class="edition-tab-default">Default</span>' : '';
                    return `<tr>
                        <td>${e.edition_type}${defBadge}</td>
                        <td>${dur}</td><td>${res}</td><td>${codec}</td><td>${audio}</td><td>${src}</td><td>${dr}</td><td>${size}</td>
                        <td><button class="edition-tab-play" onclick="playMedia('${e.media_item_id}','${e.title.replace(/'/g,"\\'")}')">&#9654; Play</button></td>
                    </tr>`;
                }).join('');
                tc.innerHTML = `<h4 class="edition-tab-heading">Editions (${eds.length})</h4>
                    <table class="edition-tab-table">
                        <thead><tr><th>Edition</th><th>Runtime</th><th>Resolution</th><th>Codec</th><th>Audio</th><th>Source</th><th>DR</th><th>Size</th><th></th></tr></thead>
                        <tbody>${rows}</tbody>
                    </table>`;
            } else {
                tc.innerHTML = '<p style="color:#5a6a7f;">No editions found</p>';
            }
        } else if (tab === 'metadata') {
            tc.innerHTML = '<div class="spinner"></div>';
            const data = await api('GET', '/media/' + mediaId);
            if (data.success) {
                const m = data.data;
                let ids = null;
                try { if (m.external_ids) ids = JSON.parse(m.external_ids); } catch(e) {}

                let html = '<div class="metadata-tab-badges">';
                // Cache server badge
                if (ids && ids.cache_server) {
                    html += '<span class="tag tag-green">Cache Server</span>';
                } else {
                    html += '<span class="tag" style="background:rgba(100,116,139,0.15);color:#94a3b8;border:1px solid rgba(100,116,139,0.2);">Direct API</span>';
                }
                // Source badge
                if (ids && ids.source) {
                    const srcLabel = {tmdb:'TMDB',porndb:'ThePornDB',musicbrainz:'MusicBrainz',openlibrary:'OpenLibrary'}[ids.source] || ids.source;
                    html += '<span class="tag tag-cyan">Source: ' + srcLabel + '</span>';
                }
                html += '</div>';

                // External IDs section
                const idRows = [];
                if (ids) {
                    if (ids.tmdb_id) idRows.push({name:'TMDB', id:ids.tmdb_id, url:'https://www.themoviedb.org/movie/'+ids.tmdb_id});
                    if (ids.imdb_id) idRows.push({name:'IMDB', id:ids.imdb_id, url:'https://www.imdb.com/title/'+ids.imdb_id+'/'});
                    if (ids.tpdb_id) idRows.push({name:'ThePornDB', id:ids.tpdb_id, url:'https://theporndb.net/movies/'+ids.tpdb_id});
                    if (ids.musicbrainz_id) idRows.push({name:'MusicBrainz', id:ids.musicbrainz_id, url:'https://musicbrainz.org/release/'+ids.musicbrainz_id});
                    if (ids.openlibrary_id) idRows.push({name:'OpenLibrary', id:ids.openlibrary_id, url:'https://openlibrary.org/works/'+ids.openlibrary_id});
                }

                html += '<div class="metadata-tab-section">';
                html += '<h4 class="metadata-tab-heading">External IDs</h4>';
                if (idRows.length > 0) {
                    html += '<table class="metadata-ids-table">';
                    html += '<thead><tr><th>Service</th><th>External ID</th></tr></thead><tbody>';
                    idRows.forEach(r => {
                        html += '<tr><td class="metadata-ids-service">' + r.name + '</td>';
                        html += '<td><a href="' + r.url + '" target="_blank" rel="noopener" class="metadata-ids-link">' + r.id + '</a></td></tr>';
                    });
                    html += '</tbody></table>';
                } else {
                    html += '<p style="color:var(--text-muted);">No external IDs stored. Run a metadata refresh or identify this item to populate.</p>';
                }
                html += '</div>';

                // Technical metadata section
                const techRows = [];
                if (m.source_type) techRows.push({k:'Source', v:m.source_type});
                if (m.dynamic_range && m.dynamic_range !== 'SDR') techRows.push({k:'Dynamic Range', v:m.dynamic_range + (m.hdr_format ? ' ('+m.hdr_format+')' : '')});
                if (m.custom_notes) techRows.push({k:'Custom Notes', v:m.custom_notes});
                const ctRaw = m.custom_tags ? (typeof m.custom_tags === 'string' ? JSON.parse(m.custom_tags || '{}') : m.custom_tags) : {};
                const ctArr = ctRaw.tags || [];
                if (ctArr.length > 0) techRows.push({k:'Custom Tags', v:ctArr.map(t=>'<span class="tag tag-blue">'+t+'</span>').join(' ')});
                if (techRows.length > 0) {
                    html += '<div class="metadata-tab-section">';
                    html += '<h4 class="metadata-tab-heading">Technical &amp; Custom Metadata</h4>';
                    html += '<table class="metadata-tech-table">';
                    techRows.forEach(r => {
                        html += '<tr><td class="metadata-tech-label">'+r.k+'</td><td class="metadata-tech-value">'+r.v+'</td></tr>';
                    });
                    html += '</table>';
                    html += '</div>';
                }

                tc.innerHTML = html;
            }
        } else if (tab === 'segments') {
            tc.innerHTML = '<div class="spinner"></div>';
            const segRes = await api('GET', '/media/' + mediaId + '/segments');
            const isAdmin = currentUser && currentUser.role === 'admin';
            const segs = (segRes.success && segRes.data) ? segRes.data : [];

            if (segs.length > 0) {
                const typeLabel = { intro: 'Intro', credits: 'Credits', recap: 'Recap', preview: 'Preview' };
                const sourceLabel = { auto: 'Auto-detected', manual: 'Manual', community: 'Community' };
                let html = '<table style="width:100%;font-size:0.85rem;">';
                html += '<thead><tr><th style="text-align:left;padding:6px 12px 6px 0;color:#8a9bae;">Type</th><th style="text-align:left;padding:6px 12px;color:#8a9bae;">Start</th><th style="text-align:left;padding:6px 12px;color:#8a9bae;">End</th><th style="text-align:left;padding:6px 12px;color:#8a9bae;">Confidence</th><th style="text-align:left;padding:6px 12px;color:#8a9bae;">Source</th>';
                if (isAdmin) html += '<th style="padding:6px 0;"></th>';
                html += '</tr></thead><tbody>';
                segs.forEach(seg => {
                    html += `<tr>
                        <td style="padding:6px 12px 6px 0;"><span class="tag tag-cyan">${typeLabel[seg.segment_type] || seg.segment_type}</span></td>
                        <td style="padding:6px 12px;">${formatTime(seg.start_seconds)}</td>
                        <td style="padding:6px 12px;">${formatTime(seg.end_seconds)}</td>
                        <td style="padding:6px 12px;">${Math.round(seg.confidence * 100)}%</td>
                        <td style="padding:6px 12px;">${sourceLabel[seg.source] || seg.source}${seg.verified ? ' &#9989;' : ''}</td>
                        ${isAdmin ? '<td style="padding:6px 0;"><button class="btn-danger btn-small" onclick="deleteSegment(\''+mediaId+'\',\''+seg.segment_type+'\')">Delete</button></td>' : ''}
                    </tr>`;
                });
                html += '</tbody></table>';
                if (isAdmin) html += `<div style="margin-top:16px;"><button class="btn-secondary btn-small" onclick="showAddSegmentForm('${mediaId}')">+ Add Segment</button></div>`;
                tc.innerHTML = html;
            } else {
                let html = '<p style="color:#5a6a7f;margin-bottom:16px;">No skip segments detected for this item.</p>';
                if (isAdmin) html += `<button class="btn-secondary btn-small" onclick="showAddSegmentForm('${mediaId}')">+ Add Segment Manually</button>`;
                tc.innerHTML = html;
            }
        } else if (tab === 'file') {
            tc.innerHTML = '<p style="color:#5a6a7f;">Loading file info...</p>';
            const data = await api('GET', '/media/' + mediaId);
            if (data.success) {
                const m = data.data;
                tc.innerHTML = `<table style="width:100%;font-size:0.85rem;">
                    <tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">File</td><td>${m.file_name}</td></tr>
                    <tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Path</td><td style="word-break:break-all;">${m.file_path}</td></tr>
                    ${m.width ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Resolution</td><td>'+m.width+'x'+m.height+'</td></tr>' : ''}
                    ${m.codec ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Video Codec</td><td>'+m.codec+'</td></tr>' : ''}
                    ${m.audio_codec ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Audio Codec</td><td>'+m.audio_codec+'</td></tr>' : ''}
                    ${m.source_type ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Source</td><td>'+m.source_type+'</td></tr>' : ''}
                    ${m.dynamic_range && m.dynamic_range !== 'SDR' ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Dynamic Range</td><td>'+m.dynamic_range+(m.hdr_format ? ' ('+m.hdr_format+')' : '')+'</td></tr>' : ''}
                    ${m.bitrate ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Bitrate</td><td>'+(m.bitrate/1000).toFixed(0)+' kbps</td></tr>' : ''}
                    ${m.file_hash ? '<tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">MD5 Hash</td><td style="font-family:monospace;font-size:0.78rem;">'+m.file_hash+'</td></tr>' : ''}
                    <tr><td style="color:#5a6a7f;padding:4px 16px 4px 0;">Added</td><td>${new Date(m.added_at).toLocaleString()}</td></tr>
                </table>`;
            }
        }
    }

    // ──── Manual Segment Editor ────
    function showAddSegmentForm(mediaId) {
        const tc = document.getElementById('detailTabContent');
        tc.innerHTML += `
            <div class="segment-editor" style="margin-top:20px;padding:16px;background:var(--surface-card);border-radius:var(--radius-lg);border:1px solid var(--border-subtle);">
                <h4 style="color:#e5e5e5;margin:0 0 12px;">Add Skip Segment</h4>
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;">
                    <div>
                        <label style="color:#8a9bae;font-size:0.8rem;">Type</label>
                        <select id="segType" style="width:100%;padding:8px;background:var(--bg-secondary);border:1px solid var(--border-subtle-input);border-radius:var(--radius-md);color:#e5e5e5;">
                            <option value="intro">Intro</option>
                            <option value="credits">Credits</option>
                            <option value="recap">Recap</option>
                            <option value="preview">Preview</option>
                        </select>
                    </div>
                    <div>
                        <label style="color:#8a9bae;font-size:0.8rem;">Start (seconds)</label>
                        <input type="number" id="segStart" step="0.1" min="0" placeholder="0.0" style="width:100%;padding:8px;background:var(--bg-secondary);border:1px solid var(--border-subtle-input);border-radius:var(--radius-md);color:#e5e5e5;">
                    </div>
                    <div>
                        <label style="color:#8a9bae;font-size:0.8rem;">End (seconds)</label>
                        <input type="number" id="segEnd" step="0.1" min="0" placeholder="90.0" style="width:100%;padding:8px;background:var(--bg-secondary);border:1px solid var(--border-subtle-input);border-radius:var(--radius-md);color:#e5e5e5;">
                    </div>
                </div>
                <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end;">
                    <button class="btn-secondary btn-small" onclick="showDetailTab(document.querySelector('.detail-tab[onclick*=segments]'),'segments','${mediaId}')">Cancel</button>
                    <button class="btn-primary btn-small" onclick="saveSegment('${mediaId}')">Save</button>
                </div>
            </div>`;
    }

    async function saveSegment(mediaId) {
        const segType = document.getElementById('segType').value;
        const start = parseFloat(document.getElementById('segStart').value);
        const end = parseFloat(document.getElementById('segEnd').value);
        if (isNaN(start) || isNaN(end) || end <= start) {
            toast('Invalid time range', 'error');
            return;
        }
        const res = await api('POST', '/media/' + mediaId + '/segments', {
            segment_type: segType,
            start_seconds: start,
            end_seconds: end,
            verified: true
        });
        if (res.success) {
            toast('Segment saved!');
            const btn = document.querySelector('.detail-tab[onclick*="segments"]');
            if (btn) showDetailTab(btn, 'segments', mediaId);
        } else {
            toast(res.error || 'Failed to save segment', 'error');
        }
    }

    async function deleteSegment(mediaId, segType) {
        if (!confirm('Delete this ' + segType + ' segment?')) return;
        const res = await api('DELETE', '/media/' + mediaId + '/segments/' + segType);
        if (res.success) {
            toast('Segment deleted');
            const btn = document.querySelector('.detail-tab[onclick*="segments"]');
            if (btn) showDetailTab(btn, 'segments', mediaId);
        } else {
            toast(res.error || 'Failed to delete', 'error');
        }
    }

    // ──── Paginated Media Grid with Alpha Jump ────
    let _gridState = { libraryId: null, offset: 0, total: 0, loading: false, done: false, observer: null, letterIndex: [], filters: {} };
    let _filterOpts = {};
    let _pickerVals = [];

    const FILTER_DEFS = [
        { key: 'genre', label: 'Genre', apiKey: 'genres' },
        { key: 'country', label: 'Country', apiKey: 'countries' },
        { key: 'content_rating', label: 'Content Rating', apiKey: 'content_ratings' },
        { key: 'folder', label: 'Folder', apiKey: 'folders', displayFn: v => v.split('/').filter(Boolean).pop() || v },
        { key: 'edition', label: 'Edition', apiKey: 'editions' },
        { key: 'source', label: 'Source', apiKey: 'sources', displayFn: v => v.charAt(0).toUpperCase() + v.slice(1) },
        { key: 'dynamic_range', label: 'Dynamic Range', apiKey: 'dynamic_ranges' },
        { key: 'resolution', label: 'Resolution', apiKey: 'resolutions' },
        { key: 'codec', label: 'Codec', apiKey: 'codecs', displayMap: {'hevc':'HEVC (H.265)','h264':'H.264','av1':'AV1','mpeg4':'MPEG-4','mpeg2video':'MPEG-2','vp9':'VP9','vc1':'VC-1'} },
        { key: 'hdr_format', label: 'HDR Format', apiKey: 'hdr_formats' },
        { key: 'audio_codec', label: 'Audio Codec', apiKey: 'audio_codecs', displayMap: {'truehd':'TrueHD','eac3':'EAC3 (DD+)','ac3':'AC3 (DD)','aac':'AAC','dts':'DTS','flac':'FLAC','opus':'Opus','vorbis':'Vorbis','pcm_s16le':'PCM','pcm_s24le':'PCM 24-bit','mp3':'MP3'} },
        { key: 'bitrate_range', label: 'Bitrate', options: [{v:'low',l:'< 5 Mbps'},{v:'medium',l:'5-15 Mbps'},{v:'high',l:'15-30 Mbps'},{v:'ultra',l:'30+ Mbps'}] },
        { key: 'duration_range', label: 'Duration', options: [{v:'short',l:'< 30 min'},{v:'medium',l:'30-90 min'},{v:'long',l:'90-180 min'},{v:'vlong',l:'180+ min'}] },
        { key: 'watch_status', label: 'Watched', options: [{v:'watched',l:'Watched'},{v:'unwatched',l:'Unwatched'}] },
        { key: 'added_days', label: 'Recently Added', options: [{v:'1',l:'Today'},{v:'7',l:'Last 7 Days'},{v:'30',l:'Last 30 Days'},{v:'90',l:'Last 90 Days'}] }
    ];

    function teardownGrid() {
        if (_gridState.observer) { _gridState.observer.disconnect(); _gridState.observer = null; }
        _gridState = { libraryId: null, offset: 0, total: 0, loading: false, done: false, observer: null, letterIndex: [], filters: {} };
    }

    // Build query string from current filters
    function buildFilterQS() {
        const f = _gridState.filters || {};
        const params = [];
        const keys = ['genre','folder','content_rating','edition','source','dynamic_range',
            'codec','hdr_format','resolution','audio_codec','bitrate_range','country',
            'duration_range','watch_status','added_days','year_from','year_to','min_rating',
            'sort','order'];
        for (const k of keys) {
            if (f[k]) params.push(k + '=' + encodeURIComponent(f[k]));
        }
        return params.length > 0 ? '&' + params.join('&') : '';
    }

    async function loadMoreMedia() {
        if (_gridState.loading || _gridState.done) return;
        _gridState.loading = true;
        const m = await api('GET', '/libraries/' + _gridState.libraryId + '/media?limit=200&offset=' + _gridState.offset + buildFilterQS());
        const items = (m.success && m.data && m.data.items) ? m.data.items : [];
        _gridState.total = m.data ? m.data.total : _gridState.total;

        const grid = document.getElementById('libGrid');
        if (!grid) { _gridState.loading = false; return; }

        // Remove sentinel before appending
        const sentinel = document.getElementById('gridSentinel');
        if (sentinel) sentinel.remove();

        if (items.length === 0 && _gridState.offset === 0) {
            const type = (allLibraries.find(l => l.id === _gridState.libraryId) || {}).media_type || '';
            grid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><div class="empty-state-icon">${mediaIcon(type)}</div><div class="empty-state-title">No items in this library</div><p>Scan the library to populate it with media</p></div>`;
            _gridState.done = true;
            _gridState.loading = false;
            return;
        }

        grid.insertAdjacentHTML('beforeend', items.map(renderMediaCard).join(''));
        _gridState.offset += items.length;

        // Check if we've loaded everything
        if (_gridState.offset >= _gridState.total || items.length < 200) {
            _gridState.done = true;
            updateAlphaCount();
        } else {
            // Add sentinel for infinite scroll
            grid.insertAdjacentHTML('beforeend', '<div id="gridSentinel" class="load-more-sentinel"><div class="spinner"></div></div>');
            const newSentinel = document.getElementById('gridSentinel');
            if (newSentinel && _gridState.observer) _gridState.observer.observe(newSentinel);
        }
        _gridState.loading = false;
        updateAlphaCount();
    }

    function setupScrollObserver() {
        _gridState.observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting) loadMoreMedia();
        }, { root: document.getElementById('mainContent'), rootMargin: '800px' });
        const sentinel = document.getElementById('gridSentinel');
        if (sentinel) _gridState.observer.observe(sentinel);
    }

    function buildAlphaJump(letterIndex) {
        const allLetters = ['#','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];
        const indexMap = {};
        letterIndex.forEach(e => { indexMap[e.letter] = e; });
        return `<div class="alpha-jump" id="alphaJump">${allLetters.map(l => {
            const entry = indexMap[l];
            if (entry) {
                return `<div class="alpha-jump-letter" data-letter="${l}" data-offset="${entry.offset}" onclick="jumpToLetter(this)">${l}</div>`;
            }
            return `<div class="alpha-jump-letter disabled">${l}</div>`;
        }).join('')}</div>`;
    }

    function updateAlphaCount() {
        // Highlight the current visible letter based on scroll position
        const grid = document.getElementById('libGrid');
        const jump = document.getElementById('alphaJump');
        if (!grid || !jump) return;
        const cards = grid.querySelectorAll('.media-card');
        if (cards.length === 0) return;

        // Find the first visible card
        const container = document.getElementById('mainContent');
        const containerTop = container.getBoundingClientRect().top;
        let activeLetter = '';
        for (const card of cards) {
            const rect = card.getBoundingClientRect();
            if (rect.top >= containerTop - 50) {
                const title = card.querySelector('.media-title');
                if (title) {
                    const sortTitle = card.dataset.sortTitle || title.textContent;
                    activeLetter = sortableTitleLetter(sortTitle);
                }
                break;
            }
        }
        jump.querySelectorAll('.alpha-jump-letter').forEach(el => {
            el.classList.toggle('active', el.dataset.letter === activeLetter);
        });
    }

    // Strip leading articles (The, A, An) for alpha-jump matching
    function sortableTitleLetter(text) {
        const t = text.trim();
        const stripped = t.replace(/^(The|A|An)\s+/i, '');
        const first = stripped.charAt(0).toUpperCase();
        return (first >= 'A' && first <= 'Z') ? first : '#';
    }

    async function jumpToLetter(el) {
        const targetOffset = parseInt(el.dataset.offset);
        const letter = el.dataset.letter;
        // Load batches until we have enough items to reach this letter (with safety limit)
        let safety = 0;
        while (_gridState.offset <= targetOffset && !_gridState.done && safety < 50) {
            const prevOffset = _gridState.offset;
            await loadMoreMedia();
            // If offset didn't advance, break to avoid infinite loop
            if (_gridState.offset === prevOffset) break;
            safety++;
        }
        // Find the first card starting with this letter and scroll to it
        const grid = document.getElementById('libGrid');
        if (!grid) return;
        const cards = grid.querySelectorAll('.media-card');
        for (const card of cards) {
            const title = card.querySelector('.media-title');
            if (title) {
                const sortTitle = card.dataset.sortTitle || title.textContent;
                const cardLetter = sortableTitleLetter(sortTitle);
                if (cardLetter === letter) {
                    card.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    break;
                }
            }
        }
        document.querySelectorAll('.alpha-jump-letter').forEach(l => l.classList.remove('active'));
        el.classList.add('active');
    }

    async function loadMediaTypeView(mediaType) {
        teardownGrid();
        const mc = document.getElementById('mainContent');
        const label = MEDIA_LABELS[mediaType] || mediaType;

        // Find all libraries of this type
        const libs = await api('GET', '/libraries');
        const matchingLibs = (libs.success && libs.data) ? libs.data.filter(l => l.media_type === mediaType) : [];

        if (matchingLibs.length === 1) {
            // Single library — use paginated view
            return loadLibraryView(matchingLibs[0].id);
        }

        // Multiple libraries — load all (with pagination for each)
        mc.innerHTML = `<div class="section-header"><h2 class="section-title">${label}</h2></div>
            <div class="media-grid" id="typeGrid"><div class="spinner"></div> Loading...</div>`;
        let items = [];
        for (const lib of matchingLibs) {
            let off = 0;
            while (true) {
                const m = await api('GET', '/libraries/'+lib.id+'/media?limit=500&offset='+off);
                if (m.success && m.data && m.data.items && m.data.items.length > 0) {
                    items = items.concat(m.data.items);
                    off += m.data.items.length;
                    if (off >= m.data.total) break;
                } else break;
            }
        }
        const grid = document.getElementById('typeGrid');
        grid.innerHTML = items.length > 0
            ? items.map(renderMediaCard).join('')
            : `<div class="empty-state" style="grid-column:1/-1;"><div class="empty-state-icon">${mediaIcon(mediaType)}</div><div class="empty-state-title">No ${label.toLowerCase()} yet</div><p>Add a ${label.toLowerCase()} library and scan it</p></div>`;
    }

    async function loadLibraryView(libraryId) {
        teardownGrid();
        const mc = document.getElementById('mainContent');
        const lib = allLibraries.find(l => l.id === libraryId);
        const label = lib ? lib.name : 'Library';
        const type = lib ? lib.media_type : '';

        // TV show library with season grouping → show TV shows instead of flat episodes
        if (lib && lib.media_type === 'tv_shows' && lib.season_grouping) {
            mc.innerHTML = `<div class="section-header"><h2 class="section-title">${label}</h2><span class="tag tag-cyan" style="margin-left:12px;">TV Shows</span></div>
                <div class="media-grid" id="libGrid"><div class="spinner"></div> Loading...</div>`;
            const data = await api('GET', '/libraries/' + libraryId + '/shows');
            const shows = (data.success && data.data) ? data.data : [];
            const grid = document.getElementById('libGrid');
            grid.innerHTML = shows.length > 0
                ? shows.map(renderShowCard).join('')
                : `<div class="empty-state" style="grid-column:1/-1;"><div class="empty-state-icon">&#128250;</div><div class="empty-state-title">No TV shows yet</div><p>Scan the library to detect shows</p></div>`;
            return;
        }

        _gridState.libraryId = libraryId;

        // Fetch filter options and letter index in parallel
        const [filterData, idxData] = await Promise.all([
            api('GET', '/libraries/' + libraryId + '/filters'),
            api('GET', '/libraries/' + libraryId + '/media/index' + (buildFilterQS() ? '?' + buildFilterQS().substring(1) : ''))
        ]);
        const filterOpts = (filterData.success && filterData.data) ? filterData.data : {};
        const letterIndex = (idxData.success && idxData.data) ? idxData.data : [];
        _gridState.letterIndex = letterIndex;

        const totalCount = letterIndex.reduce((s, e) => s + e.count, 0);

        mc.innerHTML = `<div class="section-header"><h2 class="section-title">${label}</h2><span class="tag tag-cyan" style="margin-left:12px;">${MEDIA_LABELS[type]||type}</span><span class="tag" id="libItemCount" style="margin-left:8px;">${totalCount.toLocaleString()} items</span></div>
            ${buildFilterToolbar(filterOpts)}
            <div class="media-grid-wrapper" id="mediaGridWrapper">
                <div class="media-grid" id="libGrid"><div id="gridSentinel" class="load-more-sentinel"><div class="spinner"></div></div></div>
                ${buildAlphaJump(letterIndex)}
            </div>
            <div id="collectionsArea" style="display:none;"></div>
            <div id="seriesArea" style="display:none;"></div>`;

        renderFilterChips();
        setupScrollObserver();
        loadMoreMedia();

        // Update active letter on scroll
        const container = document.getElementById('mainContent');
        container.addEventListener('scroll', () => { requestAnimationFrame(updateAlphaCount); });
    }

    // ──── Filter Toolbar ────
    function escFilterHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

    function getFilterValues(def) {
        if (def.options) return def.options;
        if (def.apiKey && _filterOpts[def.apiKey] && _filterOpts[def.apiKey].length > 0) {
            return _filterOpts[def.apiKey].map(v => ({
                v: v,
                l: def.displayMap ? (def.displayMap[v] || v.toUpperCase()) :
                   def.displayFn ? def.displayFn(v) : v
            }));
        }
        return [];
    }

    function getFilterLabel(key, value) {
        const def = FILTER_DEFS.find(d => d.key === key);
        if (!def) return value;
        const vals = getFilterValues(def);
        const opt = vals.find(o => o.v === value);
        return opt ? opt.l : value;
    }

    function buildFilterToolbar(opts) {
        _filterOpts = opts;
        return `<div class="filter-toolbar" id="filterToolbar">
            <div class="ft-add-wrapper">
                <button class="ft-add-btn" onclick="toggleFilterPicker(event)">&#43; Filter</button>
                <div class="ft-picker" id="ftPicker">
                    <div class="ft-picker-cats" id="ftPickerCats"></div>
                    <div class="ft-picker-vals" id="ftPickerVals"></div>
                </div>
            </div>
            <div class="ft-chips" id="ftChips"></div>
            <div class="ft-sep"></div>
            <span class="ft-label">Year</span>
            <input type="number" id="ftYearFrom" placeholder="From" min="1900" max="2099" onchange="applyLibFilter()">
            <input type="number" id="ftYearTo" placeholder="To" min="1900" max="2099" onchange="applyLibFilter()">
            <span class="ft-label">Rating</span>
            <input type="number" id="ftMinRating" placeholder="0" min="0" max="10" step="0.5" onchange="applyLibFilter()">
            <div class="ft-sep"></div>
            <span class="ft-label">Sort</span>
            <select id="ftSort" onchange="applyLibFilter()">
                <option value="">Title</option>
                <option value="year">Year</option>
                <option value="resolution">Resolution</option>
                <option value="duration">Length</option>
                <option value="bitrate">Bitrate</option>
                <option value="rt_rating">Rotten Tomatoes</option>
                <option value="rating">TMDB Rating</option>
                <option value="audience_score">Audience Score</option>
                <option value="added_at">Date Added</option>
            </select>
            <select id="ftOrder" onchange="applyLibFilter()">
                <option value="asc">A&#8594;Z / Low&#8594;High</option>
                <option value="desc">Z&#8594;A / High&#8594;Low</option>
            </select>
            <div class="ft-sep"></div>
            <button class="ft-btn" id="ftGridBtn" onclick="showLibraryGrid()" title="Grid view">&#9638; Grid</button>
            <button class="ft-btn" id="ftCollBtn" onclick="showLibraryCollections()" title="Collections view">&#128218; Collections</button>
            <button class="ft-btn" id="ftSeriesBtn" onclick="showLibrarySeries()" title="Series view">&#127910; Series</button>
            <button class="ft-reset" onclick="resetLibFilters()" title="Reset all filters">&#10005; Reset</button>
        </div>`;
    }

    function toggleFilterPicker(e) {
        e.stopPropagation();
        const picker = document.getElementById('ftPicker');
        if (picker.classList.contains('open')) { closeFilterPicker(); return; }
        const catsEl = document.getElementById('ftPickerCats');
        const valsEl = document.getElementById('ftPickerVals');
        let catHtml = '';
        for (const def of FILTER_DEFS) {
            if ((_gridState.filters || {})[def.key]) continue;
            const vals = getFilterValues(def);
            if (!vals || vals.length === 0) continue;
            catHtml += `<div class="ft-picker-cat" data-key="${def.key}" onclick="showFilterValues('${def.key}')" onmouseenter="showFilterValues('${def.key}')">${escFilterHtml(def.label)}<span class="ft-picker-cat-count">${vals.length}</span></div>`;
        }
        catsEl.innerHTML = catHtml || '<div class="ft-picker-empty">No more filters available</div>';
        valsEl.innerHTML = '<div class="ft-picker-hint">Hover a category to see options</div>';
        picker.classList.add('open');
        setTimeout(() => document.addEventListener('click', _closePickerOnOutside), 0);
    }

    function _closePickerOnOutside(e) {
        const wrapper = document.querySelector('.ft-add-wrapper');
        if (wrapper && !wrapper.contains(e.target)) closeFilterPicker();
    }

    function closeFilterPicker() {
        const picker = document.getElementById('ftPicker');
        if (picker) picker.classList.remove('open');
        document.removeEventListener('click', _closePickerOnOutside);
    }

    function showFilterValues(key) {
        const def = FILTER_DEFS.find(d => d.key === key);
        if (!def) return;
        _pickerVals = getFilterValues(def);
        const valsEl = document.getElementById('ftPickerVals');
        const searchBox = _pickerVals.length > 10
            ? `<div class="ft-picker-search"><input type="text" placeholder="Search ${def.label.toLowerCase()}..." oninput="filterPickerVals(this.value)" onclick="event.stopPropagation()"></div>` : '';
        valsEl.innerHTML = searchBox + `<div class="ft-picker-val-list" id="ftPickerValList">${_pickerVals.map((opt, i) =>
            `<div class="ft-picker-val" onclick="pickFilterValue('${key}',${i})">${escFilterHtml(opt.l)}</div>`
        ).join('')}</div>`;
        document.querySelectorAll('.ft-picker-cat').forEach(el => {
            el.classList.toggle('active', el.dataset.key === key);
        });
    }

    function filterPickerVals(q) {
        const list = document.getElementById('ftPickerValList');
        if (!list) return;
        const lq = q.toLowerCase();
        list.querySelectorAll('.ft-picker-val').forEach(el => {
            el.style.display = el.textContent.toLowerCase().includes(lq) ? '' : 'none';
        });
    }

    function pickFilterValue(key, idx) {
        const value = _pickerVals[idx].v;
        if (!_gridState.filters) _gridState.filters = {};
        _gridState.filters[key] = value;
        closeFilterPicker();
        renderFilterChips();
        reloadLibraryGrid();
    }

    function removeFilter(key) {
        if (_gridState.filters) delete _gridState.filters[key];
        renderFilterChips();
        reloadLibraryGrid();
    }

    function renderFilterChips() {
        const chipsEl = document.getElementById('ftChips');
        if (!chipsEl) return;
        const f = _gridState.filters || {};
        let html = '';
        for (const def of FILTER_DEFS) {
            if (!f[def.key]) continue;
            const label = getFilterLabel(def.key, f[def.key]);
            html += `<div class="ft-chip"><span class="ft-chip-cat">${escFilterHtml(def.label)}:</span> ${escFilterHtml(label)}<span class="ft-chip-x" onclick="removeFilter('${def.key}')" title="Remove filter">&times;</span></div>`;
        }
        chipsEl.innerHTML = html;
    }

    function applyLibFilter() {
        const f = {};
        // Preserve chip-based filters
        const pickerKeys = new Set(FILTER_DEFS.map(d => d.key));
        const existing = _gridState.filters || {};
        for (const k of pickerKeys) { if (existing[k]) f[k] = existing[k]; }
        // Read DOM inputs
        const yearFrom = document.getElementById('ftYearFrom');
        const yearTo = document.getElementById('ftYearTo');
        const minRating = document.getElementById('ftMinRating');
        const sort = document.getElementById('ftSort');
        const order = document.getElementById('ftOrder');
        if (yearFrom && yearFrom.value) f.year_from = yearFrom.value;
        if (yearTo && yearTo.value) f.year_to = yearTo.value;
        if (minRating && minRating.value) f.min_rating = minRating.value;
        if (sort && sort.value) f.sort = sort.value;
        if (order && order.value !== 'asc') f.order = order.value;
        _gridState.filters = f;
        reloadLibraryGrid();
    }

    function resetLibFilters() {
        ['ftSort','ftOrder'].forEach(id => { const el = document.getElementById(id); if (el) el.selectedIndex = 0; });
        ['ftYearFrom','ftYearTo','ftMinRating'].forEach(id => { const el = document.getElementById(id); if (el) el.value = ''; });
        _gridState.filters = {};
        renderFilterChips();
        reloadLibraryGrid();
    }

    async function reloadLibraryGrid() {
        const libId = _gridState.libraryId;
        if (!libId) return;

        // Reset grid state but keep libraryId and filters
        const filters = _gridState.filters;
        if (_gridState.observer) { _gridState.observer.disconnect(); _gridState.observer = null; }
        _gridState.offset = 0;
        _gridState.total = 0;
        _gridState.loading = false;
        _gridState.done = false;
        _gridState.filters = filters;

        // Refresh letter index with filters
        const qs = buildFilterQS();
        const idxData = await api('GET', '/libraries/' + libId + '/media/index' + (qs ? '?' + qs.substring(1) : ''));
        const letterIndex = (idxData.success && idxData.data) ? idxData.data : [];
        _gridState.letterIndex = letterIndex;

        const totalCount = letterIndex.reduce((s, e) => s + e.count, 0);
        const countEl = document.getElementById('libItemCount');
        if (countEl) countEl.textContent = totalCount.toLocaleString() + ' items';

        // Show grid, hide collections and series
        const wrapper = document.getElementById('mediaGridWrapper');
        const collArea = document.getElementById('collectionsArea');
        const serArea = document.getElementById('seriesArea');
        if (wrapper) wrapper.style.display = 'flex';
        if (collArea) collArea.style.display = 'none';
        if (serArea) serArea.style.display = 'none';

        // Rebuild grid
        const grid = document.getElementById('libGrid');
        if (grid) {
            grid.innerHTML = '<div id="gridSentinel" class="load-more-sentinel"><div class="spinner"></div></div>';
        }

        // Rebuild alpha jump
        const existingJump = document.querySelector('.alpha-jump');
        if (existingJump) existingJump.outerHTML = buildAlphaJump(letterIndex);

        // Update toggle buttons
        const gridBtn = document.getElementById('ftGridBtn');
        const collBtn = document.getElementById('ftCollBtn');
        const serBtn = document.getElementById('ftSeriesBtn');
        if (gridBtn) gridBtn.classList.add('active');
        if (collBtn) collBtn.classList.remove('active');
        if (serBtn) serBtn.classList.remove('active');

        setupScrollObserver();
        loadMoreMedia();
    }

    function showLibraryGrid() {
        const wrapper = document.getElementById('mediaGridWrapper');
        const collArea = document.getElementById('collectionsArea');
        const serArea = document.getElementById('seriesArea');
        if (wrapper) wrapper.style.display = 'flex';
        if (collArea) collArea.style.display = 'none';
        if (serArea) serArea.style.display = 'none';
        const gridBtn = document.getElementById('ftGridBtn');
        const collBtn = document.getElementById('ftCollBtn');
        const serBtn = document.getElementById('ftSeriesBtn');
        if (gridBtn) gridBtn.classList.add('active');
        if (collBtn) collBtn.classList.remove('active');
        if (serBtn) serBtn.classList.remove('active');
    }

    async function showLibraryCollections() {
        const libId = _gridState.libraryId;
        if (!libId) return;

        const wrapper = document.getElementById('mediaGridWrapper');
        const collArea = document.getElementById('collectionsArea');
        const serArea = document.getElementById('seriesArea');
        if (wrapper) wrapper.style.display = 'none';
        if (collArea) collArea.style.display = 'block';
        if (serArea) serArea.style.display = 'none';

        const gridBtn = document.getElementById('ftGridBtn');
        const collBtn = document.getElementById('ftCollBtn');
        const serBtn = document.getElementById('ftSeriesBtn');
        if (gridBtn) gridBtn.classList.remove('active');
        if (collBtn) collBtn.classList.add('active');
        if (serBtn) serBtn.classList.remove('active');

        collArea.innerHTML = '<div class="spinner"></div> Loading collections...';
        const data = await api('GET', '/collections?library_id=' + libId);
        const collections = (data.success && data.data) ? data.data : [];

        // Header with action buttons
        let html = `<div class="section-header" style="margin-bottom:16px;">
            <h2 class="section-title" style="font-size:var(--text-lg);margin:0;">Collections</h2>
            <div style="display:flex;gap:8px;">
                <button class="btn-secondary" onclick="createCollectionTemplates('${libId}')" title="Create smart collection presets">+ Templates</button>
                <button class="btn-primary" onclick="showCreateCollection(null, '${libId}')">+ New</button>
            </div>
        </div>`;

        if (collections.length === 0) {
            collArea.innerHTML = html + '<div class="empty-state"><div class="empty-state-icon">&#128218;</div><div class="empty-state-title">No collections</div><p>Create a collection or use templates to get started</p></div>';
            return;
        }

        // Show only top-level collections (no parent)
        const topLevel = collections.filter(c => !c.parent_collection_id);
        const toShow = topLevel.length > 0 ? topLevel : collections;
        collArea.innerHTML = html + '<div class="collection-grid">' + toShow.map(c => {
            const poster = c.poster_path
                ? `<img src="${posterSrc(c.poster_path, c.updated_at)}" alt="">`
                : '&#128218;';
            const childInfo = c.child_count > 0 ? `<div class="cc-children">${c.child_count} sub-collection${c.child_count !== 1 ? 's' : ''}</div>` : '';
            return `<div class="collection-card" onclick="navigate('collection','${c.id}')">
                <div class="cc-poster">${poster}</div>
                <div class="cc-info">
                    <div class="cc-name">${c.name}</div>
                    <div class="cc-meta">${c.item_count || 0} item${(c.item_count||0) !== 1 ? 's' : ''}</div>
                    ${childInfo}
                </div>
            </div>`;
        }).join('') + '</div>';
    }

    function renderShowCard(show) {
        const year = show.year || '';
        const desc = show.description ? show.description.substring(0, 100) + '...' : '';
        return `<div class="media-card" onclick="loadShowView('${show.id}')">
            <div class="media-poster" style="position:relative;">
                ${show.poster_path ? '<img src="'+posterSrc(show.poster_path, show.updated_at)+'" alt="">' : '&#128250;'}
                ${renderOverlayBadges(show)}
            </div>
            <div class="media-info"><div class="media-title">${show.title}</div><div class="media-meta">${year}</div></div>
        </div>`;
    }

    async function loadShowView(showId) {
        const mc = document.getElementById('mainContent');
        mc.innerHTML = '<div class="spinner"></div> Loading...';
        const data = await api('GET', '/tv/shows/' + showId);
        if (!data.success) { mc.innerHTML = '<div class="empty-state"><div class="empty-state-title">Show not found</div></div>'; return; }
        const show = data.data.show;
        const seasons = data.data.seasons || [];
        const totalEps = seasons.reduce((sum, s) => sum + (s.episode_count || 0), 0);

        // Fetch missing episode data for the library
        let missingMap = {}; // seasonId -> {missing_numbers, have_count, expected_count}
        let totalMissing = 0;
        const libId = show.library_id;
        if (libId) {
            const missingData = await api('GET', '/libraries/' + libId + '/missing-episodes');
            if (missingData.success && missingData.data && missingData.data.shows) {
                const showMissing = missingData.data.shows.find(s => s.show_id === showId);
                if (showMissing) {
                    totalMissing = showMissing.total_missing;
                    (showMissing.seasons || []).forEach(sm => { missingMap[sm.season_id] = sm; });
                }
            }
        }

        const missingBadge = totalMissing > 0 ? ` <span class="tag tag-warning" style="margin-left:8px;">${totalMissing} missing episode${totalMissing !== 1 ? 's' : ''}</span>` : '';

        const heroHTML = `
            <div class="detail-hero">
                <div class="detail-poster">${show.poster_path ? '<img src="'+posterSrc(show.poster_path, show.updated_at)+'">' : '&#128250;'}</div>
                <div class="detail-info">
                    <h1>${show.title}</h1>
                    <div class="meta-row">${show.year ? show.year + ' \u00b7 ' : ''}${seasons.length} Season${seasons.length !== 1 ? 's' : ''} \u00b7 ${totalEps} Episode${totalEps !== 1 ? 's' : ''}${missingBadge}</div>
                    ${show.description ? '<p class="description">'+show.description+'</p>' : ''}
                </div>
            </div>`;

        if (seasons.length === 1) {
            const sm = missingMap[seasons[0].id];
            const singleMissing = sm ? `<div class="missing-episodes-banner">${sm.have_count}/${sm.expected_count} episodes \u00b7 Missing: ${sm.missing_numbers.join(', ')}</div>` : '';
            mc.innerHTML = heroHTML + `
                <h3 style="color:#e5e5e5;margin:24px 0 16px;">${totalEps} Episode${totalEps !== 1 ? 's' : ''}</h3>
                ${singleMissing}
                <div class="media-grid" id="season-${seasons[0].id}"><div class="spinner"></div></div>
                <button class="btn-secondary" onclick="history.back(); return false;" style="margin-top:20px;">&#8592; Back</button>`;
            loadSeasonEpisodes(seasons[0].id);
        } else {
            mc.innerHTML = heroHTML + `
                <h3 style="color:#e5e5e5;margin:24px 0 16px;">Seasons</h3>
                <div class="media-grid" id="seasonsGrid">
                    ${seasons.map(s => {
                        const sm = missingMap[s.id];
                        const missingLabel = sm ? `<div class="media-meta missing-meta">${sm.have_count}/${sm.expected_count} eps \u00b7 ${sm.missing_numbers.length} missing</div>` : '';
                        return `<div class="media-card" onclick="loadSeasonView('${showId}','${s.id}', ${s.season_number})">
                        <div class="media-poster">
                            ${s.poster_path ? '<img src="'+posterSrc(s.poster_path, s.updated_at)+'" alt="">' : (show.poster_path ? '<img src="'+posterSrc(show.poster_path, show.updated_at)+'" alt="">' : '&#128250;')}
                        </div>
                        <div class="media-info">
                            <div class="media-title">${s.title || 'Season ' + s.season_number}</div>
                            <div class="media-meta">${s.episode_count} episode${s.episode_count !== 1 ? 's' : ''}</div>
                            ${missingLabel}
                        </div>
                    </div>`;
                    }).join('')}
                </div>
                <button class="btn-secondary" onclick="history.back(); return false;" style="margin-top:20px;">&#8592; Back</button>`;
        }
    }

    async function loadSeasonView(showId, seasonId, seasonNum) {
        const mc = document.getElementById('mainContent');
        mc.innerHTML = '<div class="spinner"></div> Loading...';
        // Get show info and missing episode data in parallel
        const [showData, missingData] = await Promise.all([
            api('GET', '/tv/shows/' + showId),
            api('GET', '/tv/seasons/' + seasonId + '/missing')
        ]);
        if (!showData.success) { mc.innerHTML = '<div class="empty-state"><div class="empty-state-title">Show not found</div></div>'; return; }
        const show = showData.data.show;
        const seasons = showData.data.seasons || [];
        const season = seasons.find(s => s.id === seasonId);
        const epCount = season ? season.episode_count : 0;

        let missingBanner = '';
        if (missingData.success && missingData.data && missingData.data.missing_numbers && missingData.data.missing_numbers.length > 0) {
            const md = missingData.data;
            missingBanner = `<div class="missing-episodes-banner">${md.have_count}/${md.expected_count} episodes \u00b7 Missing: ${md.missing_numbers.join(', ')}</div>`;
        }

        mc.innerHTML = `
            <div class="detail-hero">
                <div class="detail-poster">${season && season.poster_path ? '<img src="'+posterSrc(season.poster_path, season.updated_at)+'">' : (show.poster_path ? '<img src="'+posterSrc(show.poster_path, show.updated_at)+'">' : '&#128250;')}</div>
                <div class="detail-info">
                    <h1>${show.title}</h1>
                    <div class="meta-row">Season ${seasonNum} \u00b7 ${epCount} Episode${epCount !== 1 ? 's' : ''}</div>
                    ${season && season.description ? '<p class="description">'+season.description+'</p>' : (show.description ? '<p class="description">'+show.description+'</p>' : '')}
                </div>
            </div>
            <h3 style="color:#e5e5e5;margin:24px 0 16px;">${epCount} Episode${epCount !== 1 ? 's' : ''}</h3>
            ${missingBanner}
            <div class="media-grid" id="season-${seasonId}"><div class="spinner"></div></div>
            <button class="btn-secondary" onclick="loadShowView('${showId}')" style="margin-top:20px;">&#8592; Back to ${show.title}</button>`;
        loadSeasonEpisodes(seasonId);
    }

    async function loadSeasonEpisodes(seasonId) {
        const container = document.getElementById('season-' + seasonId);
        if (!container) return;
        const data = await api('GET', '/tv/seasons/' + seasonId + '/episodes');
        const episodes = (data.success && data.data) ? data.data : [];
        container.innerHTML = episodes.length > 0
            ? episodes.map(ep => {
                const epNum = ep.episode_number ? 'Episode ' + ep.episode_number : '';
                const dur = ep.duration_seconds ? Math.floor(ep.duration_seconds/60)+'min' : '';
                const res = ep.resolution || '';
                const meta = [epNum, dur, res].filter(Boolean).join(' \u00b7 ');
                return `<div class="media-card" onclick="loadMediaDetail('${ep.id}')">
                    <div class="media-poster" style="position:relative;">
                        ${ep.poster_path ? '<img src="'+posterSrc(ep.poster_path, ep.updated_at)+'" alt="">' : '&#128250;'}
                        ${renderOverlayBadges(ep)}
                        <div class="play-overlay"><div class="play-button">&#9654;</div></div>
                    </div>
                    <div class="media-info"><div class="media-title">${ep.title}</div><div class="media-meta">${meta}</div></div>
                </div>`;
            }).join('')
            : '<p style="color:#5a6a7f;">No episodes found</p>';
    }

    async function loadSearchView(query) {
        const mc = document.getElementById('mainContent');
        mc.innerHTML = `<div class="section-header"><h2 class="section-title">Search: "${query}"</h2></div><div class="media-grid" id="searchGrid"><div class="spinner"></div> Searching...</div>`;
        const data = await api('GET', '/media/search?q=' + encodeURIComponent(query));
        const grid = document.getElementById('searchGrid');
        grid.innerHTML = (data.success && data.data && data.data.length > 0) ? data.data.map(renderMediaCard).join('') : '<div class="empty-state" style="grid-column:1/-1;"><div class="empty-state-title">No results</div></div>';
    }

    // ──── Libraries ────
    async function loadLibrariesView() {
        const mc = document.getElementById('mainContent');
        const isAdmin = currentUser && currentUser.role === 'admin';
        mc.innerHTML = `<div class="section-header"><h2 class="section-title">Libraries</h2>${isAdmin?'<button class="btn-primary" onclick="showCreateLibrary()">+ Add Library</button>':''}</div><div id="libList"><div class="spinner"></div> Loading...</div>`;
        const data = await api('GET', '/libraries');
        const div = document.getElementById('libList');
        if (data.success && data.data && data.data.length > 0) {
            div.innerHTML = data.data.map(lib => {
                const accessLabel = {everyone:'Everyone',select_users:'Select People',admin_only:'Admin Only'}[lib.access_level]||'Everyone';
                const accessColor = {everyone:'tag-green',select_users:'tag-purple',admin_only:'tag-red'}[lib.access_level]||'tag-green';
                const folderPaths = (lib.folders && lib.folders.length > 0) ? lib.folders.map(f => f.folder_path).join(', ') : lib.path;
                const folderCount = (lib.folders && lib.folders.length > 1) ? `<span class="tag tag-orange" style="margin-left:6px;">${lib.folders.length} folders</span>` : '';
                let settingsTags = '';
                if (!lib.include_in_homepage) settingsTags += '<span class="tag tag-red" style="margin-left:4px;">Hidden from Home</span>';
                if (!lib.include_in_search) settingsTags += '<span class="tag tag-red" style="margin-left:4px;">Hidden from Search</span>';
                if (!lib.retrieve_metadata) settingsTags += '<span class="tag tag-orange" style="margin-left:4px;">No Metadata</span>';
                if (lib.media_type === 'adult_movies' && lib.adult_content_type) settingsTags += `<span class="tag tag-purple" style="margin-left:4px;">${lib.adult_content_type === 'clips' ? 'Clips' : 'Movies'}</span>`;
                return `<div class="library-card" id="lib-card-${lib.id}"><div style="flex:1;"><h3>${lib.name}</h3><p style="color:#8a9bae;font-size:0.85rem;"><span class="tag tag-cyan">${MEDIA_LABELS[lib.media_type]||lib.media_type}</span>${lib.season_grouping?'<span class="tag tag-purple" style="margin-left:6px;">Season Grouping</span>':''}<span class="tag ${accessColor}" style="margin-left:6px;">${accessLabel}</span>${folderCount}<span style="margin-left:8px;">${folderPaths}</span></p><div class="lib-settings-tags">${settingsTags}</div><p style="color:#5a6a7f;font-size:0.78rem;margin-top:6px;">${lib.last_scan_at?'Last scan: '+new Date(lib.last_scan_at).toLocaleString():'Never scanned'}</p><div class="scan-progress" id="scan-progress-${lib.id}"><div class="scan-progress-bar"><div class="scan-progress-fill" id="scan-fill-${lib.id}"></div></div><div class="scan-progress-text"><span class="filename" id="scan-file-${lib.id}"></span><span id="scan-count-${lib.id}"></span></div></div></div><div class="library-actions">${isAdmin?`<button class="btn-secondary" id="scan-btn-${lib.id}" onclick="scanLibrary('${lib.id}',this)">&#128269; Scan</button><button class="btn-danger btn-small" onclick="deleteLibrary('${lib.id}')">Delete</button>`:''}</div></div>`;
            }).join('');
        } else div.innerHTML = `<div class="empty-state"><div class="empty-state-icon">&#128218;</div><div class="empty-state-title">No libraries configured</div><p>Create your first library to start organizing media</p></div>`;
    }

    async function scanLibrary(id, btn) {
        btn.disabled = true; btn.innerHTML = '<span class="spinner"></span>Scanning...';
        const prog = document.getElementById('scan-progress-' + id);
        if (prog) prog.classList.add('active');
        const countEl = document.getElementById('scan-count-' + id);
        if (countEl) countEl.textContent = 'Counting files...';
        try {
            const data = await api('POST', '/libraries/'+id+'/scan');
            if (data.success) {
                if (data.data.job_id) { /* progress handled by WebSocket events */ }
                else {
                    // Synchronous scan fallback (no job queue)
                    const r = data.data;
                    toast(`Scan: ${r.files_added} added, ${r.files_found} total`);
                    loadLibrariesView(); loadSidebarCounts();
                    btn.disabled = false; btn.innerHTML = '&#128269; Scan';
                    if (prog) prog.classList.remove('active');
                }
            } else {
                toast('Scan failed: '+(data.error||'Unknown'), 'error');
                btn.disabled = false; btn.innerHTML = '&#128269; Scan';
                if (prog) prog.classList.remove('active');
            }
        } catch(e) {
            toast('Scan error: '+e.message, 'error');
            btn.disabled = false; btn.innerHTML = '&#128269; Scan';
            if (prog) prog.classList.remove('active');
        }
    }

    async function deleteLibrary(id) { if (!confirm('Delete this library and all its media?')) return; const d=await api('DELETE','/libraries/'+id); if(d.success){toast('Library deleted');loadLibrariesView();}else toast('Failed: '+d.error,'error'); }

    function showCreateLibrary() {
        const mc = document.getElementById('mainContent');
        const types = Object.entries(MEDIA_LABELS).map(([k,v])=>`<option value="${k}">${v}</option>`).join('');
        mc.innerHTML = `<div class="section-header"><h2 class="section-title">Create Library</h2></div>
        <div style="max-width:560px;">
            <div class="form-group"><label>Name</label><input type="text" id="libName" placeholder="My Movies"></div>
            <div class="form-group"><label>Media Type</label><select id="libType" onchange="onLibTypeChange()">${types}</select></div>

            <div class="form-group">
                <label>Folders</label>
                <p style="color:#8a9bae;font-size:0.78rem;margin-bottom:8px;">At least one folder is required. Add more to scan multiple locations.</p>
                <div class="folder-list" id="folderList">
                    <div class="folder-row" data-idx="0">
                        <input type="text" class="lib-folder-input" placeholder="/media/movies" style="flex:1;">
                        <button class="btn-secondary" onclick="openFolderBrowser(0)" style="white-space:nowrap;padding:8px 12px;font-size:0.8rem;">&#128193; Browse</button>
                    </div>
                </div>
                <button class="folder-add-btn" onclick="addFolderRow()">+ Add Folder</button>
            </div>
            <div id="pathBrowser" style="display:none;margin-bottom:18px;background:rgba(0,0,0,0.3);border:1px solid rgba(0,217,255,0.15);border-radius:12px;padding:14px;max-height:350px;overflow-y:auto;"></div>

            <div id="seasonGroupingOpt" style="display:none;">
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">Group by Season</div>
                        <div class="option-row-desc">Parse SxxExx from filenames to group episodes by season</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="seasonGrouping" value="yes" checked><span>Yes</span></label>
                        <label><input type="radio" name="seasonGrouping" value="no"><span>No</span></label>
                    </div>
                </div>
            </div>

            <div id="adultContentOpt" style="display:none;">
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">Content Type</div>
                        <div class="option-row-desc">Clips &amp; Scenes will not retrieve metadata. Movies will scrape from TMDB.</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="adultContentType" value="movies" checked><span>Movies</span></label>
                        <label><input type="radio" name="adultContentType" value="clips"><span>Clips</span></label>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label>Library Permissions</label>
                <select id="libAccess" onchange="onAccessChange()">
                    <option value="everyone">Everyone</option>
                    <option value="select_users">Select People</option>
                    <option value="admin_only">Admin Only</option>
                </select>
            </div>
            <div id="userSelectPanel" style="display:none;margin-bottom:18px;background:rgba(0,0,0,0.3);border:1px solid rgba(0,217,255,0.15);border-radius:12px;padding:14px;">
                <p style="color:#8a9bae;font-size:0.8rem;margin-bottom:10px;">Select users who can access this library:</p>
                <div id="userCheckboxList"><div class="spinner"></div></div>
            </div>

            <div style="margin-bottom:18px;">
                <label style="display:block;margin-bottom:10px;font-weight:600;color:#e5e5e5;">Library Options</label>
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">Include in Homepage</div>
                        <div class="option-row-desc">Show this library's media on the home screen</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="includeHomepage" value="yes" checked><span>Yes</span></label>
                        <label><input type="radio" name="includeHomepage" value="no"><span>No</span></label>
                    </div>
                </div>
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">Include in Search</div>
                        <div class="option-row-desc">Allow this library's items to appear in search results</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="includeSearch" value="yes" checked><span>Yes</span></label>
                        <label><input type="radio" name="includeSearch" value="no"><span>No</span></label>
                    </div>
                </div>
                <div class="option-row" id="metadataOpt">
                    <div class="option-row-info">
                        <div class="option-row-label">Retrieve Metadata</div>
                        <div class="option-row-desc">Auto-populate from TMDB/MusicBrainz/OpenLibrary on scan</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="retrieveMetadata" value="yes" checked><span>Yes</span></label>
                        <label><input type="radio" name="retrieveMetadata" value="no"><span>No</span></label>
                    </div>
                </div>
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">NFO Import</div>
                        <div class="option-row-desc">Read Kodi/Jellyfin .nfo sidecar files for metadata &amp; provider IDs</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="nfoImport" value="yes"><span>Yes</span></label>
                        <label><input type="radio" name="nfoImport" value="no" checked><span>No</span></label>
                    </div>
                </div>
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">NFO Export</div>
                        <div class="option-row-desc">Write .nfo sidecar files after metadata is populated</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="nfoExport" value="yes"><span>Yes</span></label>
                        <label><input type="radio" name="nfoExport" value="no" checked><span>No</span></label>
                    </div>
                </div>
                <div class="option-row">
                    <div class="option-row-info">
                        <div class="option-row-label">Prefer Local Artwork</div>
                        <div class="option-row-desc">Use poster/backdrop/logo files found next to media before fetching remote</div>
                    </div>
                    <div class="toggle-btns">
                        <label><input type="radio" name="preferLocalArtwork" value="yes" checked><span>Yes</span></label>
                        <label><input type="radio" name="preferLocalArtwork" value="no"><span>No</span></label>
                    </div>
                </div>
            </div>

            <button class="btn-primary" onclick="createLibrary()">Create Library</button>
            <button class="btn-secondary" style="margin-left:12px;" onclick="loadLibrariesView()">Cancel</button>
        </div>`;
        onLibTypeChange();
    }

    let activeFolderIdx = null;

    function addFolderRow() {
        const list = document.getElementById('folderList');
        const idx = list.children.length;
        const row = document.createElement('div');
        row.className = 'folder-row';
        row.dataset.idx = idx;
        row.innerHTML = `<input type="text" class="lib-folder-input" placeholder="/media/folder" style="flex:1;">
            <button class="btn-secondary" onclick="openFolderBrowser(${idx})" style="white-space:nowrap;padding:8px 12px;font-size:0.8rem;">&#128193; Browse</button>
            <button class="folder-remove" onclick="removeFolderRow(this)" title="Remove folder">&#10005;</button>`;
        list.appendChild(row);
    }

    function removeFolderRow(btn) {
        const row = btn.closest('.folder-row');
        const list = document.getElementById('folderList');
        if (list.children.length <= 1) { toast('At least one folder is required', 'error'); return; }
        row.remove();
    }

    function openFolderBrowser(idx) {
        activeFolderIdx = idx;
        const inputs = document.querySelectorAll('.lib-folder-input');
        const currentPath = inputs[idx]?.value || '/media';
        openPathBrowser(currentPath);
    }

    function onLibTypeChange() {
        const type = document.getElementById('libType').value;
        const seasonOpt = document.getElementById('seasonGroupingOpt');
        const adultOpt = document.getElementById('adultContentOpt');
        if (seasonOpt) seasonOpt.style.display = (type === 'tv_shows') ? '' : 'none';
        if (adultOpt) adultOpt.style.display = (type === 'adult_movies') ? '' : 'none';
    }

    async function onAccessChange() {
        const val = document.getElementById('libAccess').value;
        const panel = document.getElementById('userSelectPanel');
        if (val === 'select_users') {
            panel.style.display = '';
            const data = await api('GET', '/users');
            const list = document.getElementById('userCheckboxList');
            if (data.success && data.data && data.data.length > 0) {
                list.innerHTML = data.data
                    .filter(u => u.role !== 'admin')
                    .map(u => `<label style="display:flex;align-items:center;gap:8px;padding:6px 0;cursor:pointer;color:#e5e5e5;">
                        <input type="checkbox" class="user-perm-cb" value="${u.id}">
                        <span>${u.username}</span>
                        <span style="color:#5a6a7f;font-size:0.75rem;margin-left:auto;">${u.role}</span>
                    </label>`).join('');
                if (list.innerHTML === '') list.innerHTML = '<p style="color:#5a6a7f;font-size:0.85rem;">No non-admin users found</p>';
            } else {
                list.innerHTML = '<p style="color:#5a6a7f;font-size:0.85rem;">No users found</p>';
            }
        } else {
            panel.style.display = 'none';
        }
    }

    async function openPathBrowser(path) {
        const browser = document.getElementById('pathBrowser');
        browser.style.display = 'block';
        await loadPathEntries(path || '/media');
    }

    async function loadPathEntries(path) {
        const browser = document.getElementById('pathBrowser');
        browser.innerHTML = '<div class="spinner" style="margin:10px auto;"></div>';
        const data = await api('GET', '/browse?path=' + encodeURIComponent(path));
        if (!data.success) { browser.innerHTML = '<p style="color:#ff5555;">Failed to browse</p>'; return; }
        const d = data.data;
        let html = `<div style="display:flex;align-items:center;gap:8px;margin-bottom:12px;padding-bottom:10px;border-bottom:1px solid rgba(0,217,255,0.1);">
            <span style="color:#00D9FF;font-size:0.8rem;font-weight:600;">&#128194; ${d.path}</span>
            <button class="btn-secondary" style="margin-left:auto;padding:4px 12px;font-size:0.75rem;" onclick="selectBrowsePath('${d.path}')">&#10003; Select This</button>
        </div>`;
        if (d.parent) {
            html += `<div onclick="loadPathEntries('${d.parent}')" style="display:flex;align-items:center;gap:8px;padding:8px 10px;cursor:pointer;border-radius:8px;color:#8a9bae;font-size:0.85rem;transition:background 0.2s;" onmouseover="this.style.background='rgba(0,217,255,0.08)'" onmouseout="this.style.background='transparent'">&#11168; ..</div>`;
        }
        if (d.entries && d.entries.length > 0) {
            d.entries.forEach(e => {
                html += `<div onclick="loadPathEntries('${e.path}')" style="display:flex;align-items:center;gap:8px;padding:8px 10px;cursor:pointer;border-radius:8px;color:#e5e5e5;font-size:0.85rem;transition:background 0.2s;" onmouseover="this.style.background='rgba(0,217,255,0.08)'" onmouseout="this.style.background='transparent'">&#128193; ${e.name}</div>`;
            });
        } else if (!d.parent) {
            html += '<p style="color:#5a6a7f;font-size:0.8rem;text-align:center;margin:12px 0;">No subdirectories</p>';
        } else {
            html += '<p style="color:#5a6a7f;font-size:0.8rem;text-align:center;margin:12px 0;">Empty folder</p>';
        }
        browser.innerHTML = html;
    }

    function selectBrowsePath(path) {
        // Multi-folder mode: set the active folder input
        if (activeFolderIdx !== null) {
            const inputs = document.querySelectorAll('.lib-folder-input');
            if (inputs[activeFolderIdx]) {
                inputs[activeFolderIdx].value = path;
            }
            activeFolderIdx = null;
        } else {
            // Fallback for single-path mode (legacy)
            const libPath = document.getElementById('libPath');
            if (libPath) libPath.value = path;
        }
        document.getElementById('pathBrowser').style.display = 'none';
    }

    async function createLibrary() {
        const name = document.getElementById('libName').value;
        const media_type = document.getElementById('libType').value;
        // Collect folders
        const folderInputs = document.querySelectorAll('.lib-folder-input');
        const folders = [...folderInputs].map(i => i.value.trim()).filter(Boolean);
        if (!name || folders.length === 0) { toast('Name and at least one folder required', 'error'); return; }

        const season_grouping = media_type === 'tv_shows' && document.querySelector('input[name="seasonGrouping"]:checked')?.value === 'yes';
        const access_level = document.getElementById('libAccess').value;
        const allowed_users = [...document.querySelectorAll('.user-perm-cb:checked')].map(cb => cb.value);
        const include_in_homepage = document.querySelector('input[name="includeHomepage"]:checked')?.value === 'yes';
        const include_in_search = document.querySelector('input[name="includeSearch"]:checked')?.value === 'yes';
        const retrieve_metadata = document.querySelector('input[name="retrieveMetadata"]:checked')?.value === 'yes';
        const nfo_import = document.querySelector('input[name="nfoImport"]:checked')?.value === 'yes';
        const nfo_export = document.querySelector('input[name="nfoExport"]:checked')?.value === 'yes';
        const prefer_local_artwork = document.querySelector('input[name="preferLocalArtwork"]:checked')?.value === 'yes';

        let adult_content_type = null;
        if (media_type === 'adult_movies') {
            adult_content_type = document.querySelector('input[name="adultContentType"]:checked')?.value || 'movies';
        }

        const d = await api('POST', '/libraries', {
            name, media_type, path: folders[0], folders, is_enabled: true,
            season_grouping, access_level, allowed_users,
            include_in_homepage, include_in_search, retrieve_metadata,
            nfo_import, nfo_export, prefer_local_artwork, adult_content_type
        });
        if (d.success) { toast('Library created!'); loadLibrariesView(); loadSidebarCounts(); }
        else toast('Failed: ' + d.error, 'error');
    }

    // ──── Collections ────
    async function loadCollectionsView() {
        const mc = document.getElementById('mainContent');
        mc.innerHTML = `<div class="section-header"><h2 class="section-title">Collections</h2>
            <div><button class="btn-secondary" onclick="createCollectionTemplates()" title="Create smart collection presets">+ Templates</button>
            <button class="btn-primary" onclick="showCreateCollection()">+ New</button></div></div>
            <div id="collList"><div class="spinner"></div></div>`;
        const data = await api('GET', '/collections');
        const div = document.getElementById('collList');
        const collections = (data.success && data.data) ? data.data : [];
        if (collections.length > 0) {
            // Show top-level collections (no parent) first
            const topLevel = collections.filter(c => !c.parent_collection_id);
            const nested = collections.filter(c => c.parent_collection_id);
            const renderCollCard = c => {
                const childBadge = c.child_count > 0 ? `<span class="tag tag-blue">${c.child_count} sub</span>` : '';
                const typeBadge = c.collection_type === 'smart' ? '<span class="tag tag-purple">Smart</span>' : '';
                return `<div class="group-card"><div style="display:flex;justify-content:space-between;align-items:flex-start;">
                    <div style="cursor:pointer;flex:1;" onclick="navigate('collection','${c.id}')">
                        <h4>${c.name}</h4>
                        ${c.description ? '<p style="color:var(--text-muted);font-size:var(--text-sm);">' + c.description + '</p>' : ''}
                        <span class="tag tag-green">${c.item_count || 0} items</span>
                        <span class="tag tag-cyan">${c.visibility}</span>
                        ${typeBadge}${childBadge}
                    </div>
                    <button class="btn-danger btn-small" onclick="event.stopPropagation();deleteCollection('${c.id}')">Delete</button>
                </div></div>`;
            };
            let html = topLevel.map(renderCollCard).join('');
            if (nested.length > 0) {
                html += '<h3 style="margin-top:20px;color:var(--text-secondary);">Nested Collections</h3>';
                html += nested.map(renderCollCard).join('');
            }
            div.innerHTML = html;
        } else {
            div.innerHTML = '<div class="empty-state"><div class="empty-state-icon">&#11088;</div><div class="empty-state-title">No collections</div><p>Create a collection or use templates to get started</p></div>';
        }
    }

    let _createCollectionLibId = null;

    // ──── Reusable Rule Picker ────
    const _rulePickerState = {};
    let _rulePickerDebounce = null;

    function initRulePicker(fieldId, options, searchFn) {
        _rulePickerState[fieldId] = { selected: [], options: options || [], searchFn: searchFn || null };
        const wrap = document.getElementById(fieldId);
        if (!wrap) return;
        _renderPickerDropdown(fieldId);
        _renderPickerChips(fieldId);
    }

    function _renderPickerDropdown(fieldId) {
        const wrap = document.getElementById(fieldId);
        const input = wrap.querySelector('.rule-picker-input');
        const dd = wrap.querySelector('.rule-picker-dropdown');
        if (!input || !dd) return;
        const st = _rulePickerState[fieldId];
        const q = input.value.toLowerCase();
        const filtered = st.options.filter(o => {
            if (st.selected.includes(o)) return false;
            return !q || o.toLowerCase().includes(q);
        });
        if (filtered.length === 0) {
            dd.innerHTML = '<div class="rule-picker-empty">' + (q ? 'No matches' : 'No options available') + '</div>';
        } else {
            dd.innerHTML = filtered.map(o =>
                `<div class="rule-picker-opt" onmousedown="rulePickerSelect('${fieldId}',this)" data-val="${escFilterHtml(o)}">${escFilterHtml(o)}</div>`
            ).join('');
        }
    }

    function rulePickerSelect(fieldId, el) {
        const val = el.dataset.val;
        const st = _rulePickerState[fieldId];
        if (!st.selected.includes(val)) {
            st.selected.push(val);
        }
        const wrap = document.getElementById(fieldId);
        const input = wrap.querySelector('.rule-picker-input');
        input.value = '';
        _renderPickerChips(fieldId);
        _renderPickerDropdown(fieldId);
    }

    function rulePickerRemove(fieldId, val) {
        const st = _rulePickerState[fieldId];
        st.selected = st.selected.filter(v => v !== val);
        _renderPickerChips(fieldId);
        _renderPickerDropdown(fieldId);
    }

    function _renderPickerChips(fieldId) {
        const wrap = document.getElementById(fieldId);
        const chipsEl = wrap.querySelector('.rule-picker-chips');
        if (!chipsEl) return;
        const st = _rulePickerState[fieldId];
        chipsEl.innerHTML = st.selected.map(v =>
            `<div class="rule-picker-chip">${escFilterHtml(v)}<span class="rule-picker-chip-x" onclick="rulePickerRemove('${fieldId}','${v.replace(/'/g,"\\'")}')">&times;</span></div>`
        ).join('');
    }

    function rulePickerInputHandler(fieldId) {
        const st = _rulePickerState[fieldId];
        if (st.searchFn) {
            clearTimeout(_rulePickerDebounce);
            _rulePickerDebounce = setTimeout(async () => {
                const wrap = document.getElementById(fieldId);
                const input = wrap.querySelector('.rule-picker-input');
                const q = input.value.trim();
                if (q.length < 2) { st.options = []; _renderPickerDropdown(fieldId); return; }
                const results = await st.searchFn(q);
                st.options = results;
                _renderPickerDropdown(fieldId);
            }, 300);
        } else {
            _renderPickerDropdown(fieldId);
        }
    }

    function rulePickerFocus(fieldId) {
        const wrap = document.getElementById(fieldId);
        const dd = wrap.querySelector('.rule-picker-dropdown');
        _renderPickerDropdown(fieldId);
        dd.classList.add('open');
    }

    function rulePickerBlur(fieldId) {
        setTimeout(() => {
            const wrap = document.getElementById(fieldId);
            if (!wrap) return;
            const dd = wrap.querySelector('.rule-picker-dropdown');
            if (dd) dd.classList.remove('open');
        }, 200);
    }

    function rulePickerKeydown(fieldId, e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            const wrap = document.getElementById(fieldId);
            const input = wrap.querySelector('.rule-picker-input');
            const val = input.value.trim();
            if (!val) return;
            const st = _rulePickerState[fieldId];
            if (!st.selected.includes(val)) { st.selected.push(val); }
            input.value = '';
            _renderPickerChips(fieldId);
            _renderPickerDropdown(fieldId);
        }
    }

    function buildPickerHtml(fieldId, placeholder, isSearch) {
        return `<div class="rule-picker" id="${fieldId}">
            <input type="text" class="rule-picker-input" placeholder="${placeholder}"
                onfocus="rulePickerFocus('${fieldId}')" onblur="rulePickerBlur('${fieldId}')"
                oninput="rulePickerInputHandler('${fieldId}')"
                onkeydown="rulePickerKeydown('${fieldId}', event)">
            <div class="rule-picker-dropdown"></div>
            <div class="rule-picker-chips"></div>
        </div>`;
    }

    function showCreateCollection(parentId, libraryId) {
        _createCollectionLibId = libraryId || null;
        _smartPickersInitialized = false;
        const mc = document.getElementById('mainContent');
        mc.innerHTML = `<div class="section-header"><h2 class="section-title">New Collection</h2></div>
        <div style="max-width:700px;">
            <div class="form-group"><label>Collection Type</label>
                <div style="display:flex;gap:10px;">
                    <button class="btn-primary" id="collTypeManualBtn" onclick="setCollType('manual')">Manual</button>
                    <button class="btn-secondary" id="collTypeSmartBtn" onclick="setCollType('smart')">Smart</button>
                </div>
            </div>
            <input type="hidden" id="collType" value="manual">
            <input type="hidden" id="collParentId" value="${parentId || ''}">
            <div class="form-group"><label>Name</label><input type="text" id="collName" placeholder="e.g. My Favorites"></div>
            <div class="form-group"><label>Description</label><input type="text" id="collDesc" placeholder="Optional description"></div>
            <div class="form-group"><label>Visibility</label>
                <select id="collVis"><option value="private">Private</option><option value="shared">Shared</option><option value="public">Public</option></select>
            </div>
            <div class="form-group"><label>Sort Mode</label>
                <select id="collSortMode">
                    <option value="custom">Custom Order</option>
                    <option value="title">Title</option>
                    <option value="year">Year</option>
                    <option value="rating">Rating</option>
                    <option value="added">Recently Added</option>
                    <option value="duration">Duration</option>
                </select>
            </div>
            <div id="smartRulesSection" style="display:none;">
                <h3 style="margin:20px 0 12px;color:var(--text-primary);">Smart Collection Rules</h3>
                <div class="smart-rule-builder">
                    <div class="rule-group"><label>Genres</label>
                        ${buildPickerHtml('ruleGenres', 'Search genres...')}
                    </div>
                    <div class="rule-group"><label>Exclude Genres</label>
                        ${buildPickerHtml('ruleExcludeGenres', 'Search genres to exclude...')}
                    </div>
                    <div class="rule-group"><label>Moods</label>
                        ${buildPickerHtml('ruleMoods', 'Search moods...')}
                    </div>
                    <div class="rule-group"><label>Performers</label>
                        ${buildPickerHtml('rulePerformers', 'Type to search performers...', true)}
                    </div>
                    <div class="rule-group"><label>Studios</label>
                        ${buildPickerHtml('ruleStudios', 'Search studios...')}
                    </div>
                    <div class="rule-group"><label>Keywords</label>
                        ${buildPickerHtml('ruleKeywords', 'Type keyword and press Enter')}
                    </div>
                    <div class="rule-group"><label>Year Range</label>
                        <div class="rule-row">
                            <input type="number" id="ruleYearFrom" placeholder="From">
                            <span style="color:var(--text-muted);">to</span>
                            <input type="number" id="ruleYearTo" placeholder="To">
                        </div>
                    </div>
                    <div class="rule-group"><label>Min Rating (0-10)</label>
                        <input type="number" id="ruleMinRating" placeholder="e.g. 7.0" step="0.1" min="0" max="10">
                    </div>
                    <div class="rule-group"><label>Duration Range (minutes)</label>
                        <div class="rule-row">
                            <input type="number" id="ruleMinDuration" placeholder="Min">
                            <span style="color:var(--text-muted);">to</span>
                            <input type="number" id="ruleMaxDuration" placeholder="Max">
                        </div>
                    </div>
                    <div class="rule-group"><label>Added Within (days)</label>
                        <input type="number" id="ruleAddedWithin" placeholder="e.g. 30">
                    </div>
                    <div class="rule-group"><label>Content Rating</label>
                        ${buildPickerHtml('ruleContentRating', 'Select content rating...')}
                    </div>
                    <div class="rule-group"><label>Sort By</label>
                        <select id="ruleSortBy">
                            <option value="">Default (Rating)</option>
                            <option value="title">Title</option>
                            <option value="year">Year</option>
                            <option value="rating">Rating</option>
                            <option value="added">Recently Added</option>
                            <option value="duration">Duration</option>
                            <option value="random">Random</option>
                        </select>
                    </div>
                    <div class="rule-group"><label>Sort Order</label>
                        <select id="ruleSortOrder">
                            <option value="desc">Descending</option>
                            <option value="asc">Ascending</option>
                        </select>
                    </div>
                    <div class="rule-group"><label>Max Results</label>
                        <input type="number" id="ruleMaxResults" placeholder="100" min="1" max="500">
                    </div>
                </div>
                <button class="btn-secondary" onclick="previewSmartRules()">Preview Matches</button>
                <div id="smartPreviewResult"></div>
            </div>
            <div style="margin-top:20px;">
                <button class="btn-primary" onclick="createCollection()">Create Collection</button>
                <button class="btn-secondary" style="margin-left:12px;" onclick="cancelCreateCollection()">Cancel</button>
            </div>
        </div>`;
    }

    let _smartPickersInitialized = false;
    function setCollType(type) {
        document.getElementById('collType').value = type;
        document.getElementById('smartRulesSection').style.display = type === 'smart' ? 'block' : 'none';
        document.getElementById('collTypeManualBtn').className = type === 'manual' ? 'btn-primary' : 'btn-secondary';
        document.getElementById('collTypeSmartBtn').className = type === 'smart' ? 'btn-primary' : 'btn-secondary';
        if (type === 'smart' && !_smartPickersInitialized) {
            _smartPickersInitialized = true;
            initSmartPickers();
        }
    }

    async function initSmartPickers() {
        let genres = [], contentRatings = [], moods = [], studios = [];
        // Fetch library-scoped filter options (genres, content ratings)
        if (_createCollectionLibId) {
            const filterData = await api('GET', '/libraries/' + _createCollectionLibId + '/filters');
            if (filterData.success && filterData.data) {
                genres = filterData.data.genres || [];
                contentRatings = filterData.data.content_ratings || [];
            }
        }
        // Fetch moods from tags
        const moodData = await api('GET', '/tags?category=mood');
        if (moodData.success && moodData.data) {
            moods = moodData.data.map(t => t.name);
        }
        // Fetch studios
        const studioData = await api('GET', '/studios?limit=500');
        if (studioData.success && studioData.data) {
            studios = studioData.data.map(s => s.name);
        }
        // Initialize pickers with fetched data
        initRulePicker('ruleGenres', genres);
        initRulePicker('ruleExcludeGenres', genres);
        initRulePicker('ruleMoods', moods);
        initRulePicker('ruleStudios', studios);
        initRulePicker('ruleContentRating', contentRatings);
        initRulePicker('ruleKeywords', []);  // free-text only
        // Performers: search-as-you-type
        initRulePicker('rulePerformers', [], async (q) => {
            const res = await api('GET', '/performers?q=' + encodeURIComponent(q) + '&limit=50');
            return (res.success && res.data) ? res.data.map(p => p.name) : [];
        });
    }

    function buildSmartRules() {
        const pickerList = id => (_rulePickerState[id] && _rulePickerState[id].selected.length > 0) ? [..._rulePickerState[id].selected] : [];
        const parseNum = id => { const v = document.getElementById(id).value.trim(); return v ? Number(v) : null; };
        const rules = {};
        const genres = pickerList('ruleGenres'); if (genres.length) rules.genres = genres;
        const excludeGenres = pickerList('ruleExcludeGenres'); if (excludeGenres.length) rules.exclude_genres = excludeGenres;
        const moods = pickerList('ruleMoods'); if (moods.length) rules.moods = moods;
        const performers = pickerList('rulePerformers'); if (performers.length) rules.performers = performers;
        const studios = pickerList('ruleStudios'); if (studios.length) rules.studios = studios;
        const keywords = pickerList('ruleKeywords'); if (keywords.length) rules.keywords = keywords;
        const contentRating = pickerList('ruleContentRating'); if (contentRating.length) rules.content_rating = contentRating;
        const yf = parseNum('ruleYearFrom'); if (yf !== null) rules.year_from = yf;
        const yt = parseNum('ruleYearTo'); if (yt !== null) rules.year_to = yt;
        const mr = parseNum('ruleMinRating'); if (mr !== null) rules.min_rating = mr;
        const minD = parseNum('ruleMinDuration'); if (minD !== null) rules.min_duration = minD;
        const maxD = parseNum('ruleMaxDuration'); if (maxD !== null) rules.max_duration = maxD;
        const aw = parseNum('ruleAddedWithin'); if (aw !== null) rules.added_within = aw;
        const sb = document.getElementById('ruleSortBy').value; if (sb) rules.sort_by = sb;
        const so = document.getElementById('ruleSortOrder').value; if (so) rules.sort_order = so;
        const maxR = parseNum('ruleMaxResults'); if (maxR !== null) rules.max_results = maxR;
        return rules;
    }

    async function previewSmartRules() {
        const rules = buildSmartRules();
        if (Object.keys(rules).length === 0) { toast('Add at least one rule', 'error'); return; }
        // Create a temporary smart collection to preview
        const tempRules = JSON.stringify(rules);
        const res = await api('POST', '/collections', { name: '__preview_temp_' + Date.now(), collection_type: 'smart', rules: tempRules, visibility: 'private' });
        if (!res.success) { document.getElementById('smartPreviewResult').innerHTML = '<div class="smart-preview-count">Error creating preview</div>'; return; }
        const tempId = res.data.id;
        const evalRes = await api('GET', '/collections/' + tempId + '/evaluate');
        await api('DELETE', '/collections/' + tempId);
        const count = (evalRes.success && evalRes.data) ? evalRes.data.length : 0;
        document.getElementById('smartPreviewResult').innerHTML = `<div class="smart-preview-count">${count} matching item${count !== 1 ? 's' : ''} found</div>`;
    }

    async function createCollection() {
        const name = document.getElementById('collName').value;
        const desc = document.getElementById('collDesc').value || null;
        const vis = document.getElementById('collVis').value;
        const sortMode = document.getElementById('collSortMode').value;
        const collType = document.getElementById('collType').value;
        const parentId = document.getElementById('collParentId').value || null;
        if (!name) { toast('Name required', 'error'); return; }

        const body = { name: name, description: desc, visibility: vis, collection_type: collType, item_sort_mode: sortMode };
        if (parentId) body.parent_collection_id = parentId;
        if (_createCollectionLibId) body.library_id = _createCollectionLibId;

        if (collType === 'smart') {
            const rules = buildSmartRules();
            if (Object.keys(rules).length === 0) { toast('Smart collections need at least one rule', 'error'); return; }
            body.rules = JSON.stringify(rules);
        }

        const r = await api('POST', '/collections', body);
        if (r.success) {
            toast('Collection created!');
            if (_createCollectionLibId) {
                // Return to library view with collections tab active
                await loadLibraryView(_createCollectionLibId);
                _createCollectionLibId = null;
                showLibraryCollections();
            } else {
                loadCollectionsView();
            }
        }
        else toast(r.error, 'error');
    }

    async function cancelCreateCollection() {
        if (_createCollectionLibId) {
            await loadLibraryView(_createCollectionLibId);
            _createCollectionLibId = null;
            showLibraryCollections();
        } else {
            loadCollectionsView();
        }
    }

    async function deleteCollection(id) {
        if (!confirm('Delete this collection?')) return;
        const d = await api('DELETE', '/collections/' + id);
        if (d.success) { toast('Deleted'); loadCollectionsView(); }
        else toast(d.error, 'error');
    }

    async function createCollectionTemplates(libraryId) {
        const r = await api('POST', '/collections/templates');
        if (r.success) {
            toast(`${r.data.count} template collection(s) created`);
            if (libraryId) {
                showLibraryCollections();
            } else {
                loadCollectionsView();
            }
        }
        else toast(r.error || 'Failed to create templates', 'error');
    }

    // ──── Add to Collection Picker ────
    async function showAddToCollectionPicker(mediaId) {
        const collRes = await api('GET', '/collections');
        const manualColls = (collRes.success && collRes.data) ? collRes.data.filter(c => c.collection_type === 'manual') : [];
        const options = manualColls.map(c => `<option value="${c.id}">${c.name} (${c.item_count || 0} items)</option>`).join('');
        // Show inline picker below detail actions
        const existing = document.getElementById('collPickerInline');
        if (existing) existing.remove();
        const picker = document.createElement('div');
        picker.id = 'collPickerInline';
        picker.style.cssText = 'display:flex;flex-direction:column;gap:8px;margin-top:10px;padding:12px;background:rgba(0,0,0,0.3);border:1px solid var(--accent-border);border-radius:10px;';
        picker.innerHTML = `
            <div style="display:flex;gap:8px;align-items:center;">
                <input type="text" id="collPickerNewName" placeholder="New collection name..." style="flex:1;">
                <button class="btn-primary btn-small" onclick="detailCreateAndAdd('${mediaId}')">Create & Add</button>
            </div>
            ${manualColls.length > 0 ? `<div style="display:flex;gap:8px;align-items:center;">
                <select id="collPickerSelect" style="flex:1;">${options}</select>
                <button class="btn-primary btn-small" onclick="addToCollection('${mediaId}')">Add</button>
            </div>` : '<div style="color:var(--text-tertiary);font-size:0.82rem;">No existing collections — create one above</div>'}
            <div style="display:flex;justify-content:flex-end;">
                <button class="btn-secondary btn-small" onclick="this.closest(\'#collPickerInline\').remove()">Cancel</button>
            </div>`;
        const actions = document.querySelector('.detail-actions');
        if (actions) actions.parentElement.insertBefore(picker, actions.nextSibling);
    }

    async function detailCreateAndAdd(mediaId) {
        const input = document.getElementById('collPickerNewName');
        const name = input.value.trim();
        if (!name) { toast('Enter a collection name', 'error'); return; }
        // Get library_id from the media item so the collection is scoped to its library
        const body = { name, collection_type: 'manual', visibility: 'private' };
        const mediaRes = await api('GET', '/media/' + mediaId);
        if (mediaRes.success && mediaRes.data && mediaRes.data.library_id) {
            body.library_id = mediaRes.data.library_id;
        }
        const res = await api('POST', '/collections', body);
        if (!res.success) { toast(res.error || 'Failed to create collection', 'error'); return; }
        const collId = res.data && res.data.id;
        if (collId) {
            const addRes = await api('POST', '/collections/' + collId + '/items', { media_item_id: mediaId });
            if (addRes.success) {
                toast('Created "' + name + '" and added item');
                const picker = document.getElementById('collPickerInline');
                if (picker) picker.remove();
            } else {
                toast('Collection created but failed to add: ' + (addRes.error || ''), 'error');
            }
        }
    }

    async function addToCollection(mediaId) {
        const sel = document.getElementById('collPickerSelect');
        if (!sel) return;
        const collId = sel.value;
        const d = await api('POST', '/collections/' + collId + '/items', { media_item_id: mediaId });
        if (d.success) {
            toast('Added to collection!');
            const picker = document.getElementById('collPickerInline');
            if (picker) picker.remove();
        } else {
            toast(d.error || 'Failed to add', 'error');
        }
    }

    async function removeFromCollection(collId, itemId) {
        const d = await api('DELETE', '/collections/' + collId + '/items/' + itemId);
        if (d.success) { toast('Removed from collection'); loadCollectionDetailView(collId); }
        else toast(d.error || 'Failed to remove', 'error');
    }

    function formatRuntime(seconds) {
        if (!seconds) return '0m';
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        return h > 0 ? h + 'h ' + m + 'm' : m + 'm';
    }

    async function loadCollectionDetailView(collId) {
        const mc = document.getElementById('mainContent');
        mc.innerHTML = '<div class="spinner"></div>';

        const [collRes, statsRes, childRes] = await Promise.all([
            api('GET', '/collections/' + collId),
            api('GET', '/collections/' + collId + '/stats'),
            api('GET', '/collections/' + collId + '/children')
        ]);

        if (!collRes.success) { mc.innerHTML = '<div class="empty-state"><div class="empty-state-title">Collection not found</div></div>'; return; }
        const coll = collRes.data;
        const stats = (statsRes.success && statsRes.data) ? statsRes.data : null;
        const children = (childRes.success && childRes.data) ? childRes.data : [];

        // Build breadcrumb
        let breadcrumb = `<div class="collection-breadcrumb">
            <a onclick="navigate('collections')">Collections</a>
            <span class="cb-sep">&#8250;</span>
            <span>${coll.name}</span>
        </div>`;

        // Header
        const poster = coll.poster_path
            ? `<img src="${posterSrc(coll.poster_path, coll.updated_at)}" alt="">`
            : '&#128218;';
        const typeBadge = coll.collection_type === 'smart' ? '<span class="tag tag-purple">Smart</span>' : '<span class="tag tag-blue">Manual</span>';

        let headerHTML = `<div class="collection-detail-header">
            <div class="collection-detail-poster">${poster}</div>
            <div class="collection-detail-info">
                <h1>${coll.name}</h1>
                ${coll.description ? '<div class="cd-desc">' + coll.description + '</div>' : ''}
                <div class="cd-badges">
                    ${typeBadge}
                    <span class="tag tag-cyan">${coll.visibility}</span>
                    <span class="tag tag-green">${coll.item_count || 0} items</span>
                </div>
                <div style="display:flex;gap:8px;margin-top:12px;">
                    <button class="btn-secondary btn-small" onclick="showCreateCollection('${coll.id}')">+ Sub-collection</button>
                    <button class="btn-danger btn-small" onclick="deleteCollection('${coll.id}');navigate('collections');">Delete</button>
                </div>
            </div>
        </div>`;

        // Stats bar
        let statsHTML = '';
        if (stats && stats.total_items > 0) {
            const genreChips = (stats.genres || []).slice(0, 6).map(g => `<span class="tag">${g.name} (${g.count})</span>`).join('');
            statsHTML = `<div class="collection-stats-bar">
                <div class="collection-stat"><span class="cs-value">${stats.total_items}</span><span class="cs-label">Items</span></div>
                <div class="collection-stat"><span class="cs-value">${formatRuntime(stats.total_runtime_seconds)}</span><span class="cs-label">Runtime</span></div>
                <div class="collection-stat"><span class="cs-value">${stats.avg_rating ? stats.avg_rating.toFixed(1) : '-'}</span><span class="cs-label">Avg Rating</span></div>
                ${genreChips ? '<div class="collection-stat-genres">' + genreChips + '</div>' : ''}
            </div>`;
        }

        // Sub-collections
        let childHTML = '';
        if (children.length > 0) {
            childHTML = `<div class="sub-collections-section"><h3>Sub-collections</h3>
                <div class="collection-grid">${children.map(c => {
                    const cp = c.poster_path ? `<img src="${posterSrc(c.poster_path, c.updated_at)}" alt="">` : '&#128218;';
                    return `<div class="collection-card" onclick="navigate('collection','${c.id}')">
                        <div class="cc-poster">${cp}</div>
                        <div class="cc-info">
                            <div class="cc-name">${c.name}</div>
                            <div class="cc-meta">${c.item_count || 0} item${(c.item_count||0) !== 1 ? 's' : ''}</div>
                        </div>
                    </div>`;
                }).join('')}</div></div>`;
        }

        // Sort bar
        const sortOptions = ['custom','title','year','rating','added','duration'];
        const sortLabels = { custom:'Custom', title:'Title', year:'Year', rating:'Rating', added:'Added', duration:'Duration' };
        let sortHTML = `<div class="collection-sort-bar">
            <div class="csb-left"><span style="color:var(--text-muted);font-size:var(--text-sm);">Sort:</span>
                <select id="collDetailSort" onchange="changeCollectionSort('${coll.id}', this.value)">
                    ${sortOptions.map(o => `<option value="${o}" ${coll.item_sort_mode === o ? 'selected' : ''}>${sortLabels[o]}</option>`).join('')}
                </select>
            </div>
            <div class="csb-right">
                <button class="btn-secondary btn-small" onclick="navigate('collections')">&#8592; Back</button>
            </div>
        </div>`;

        // Items grid
        let itemsHTML = '';
        if (coll.collection_type === 'smart') {
            // Evaluate smart collection
            const evalRes = await api('GET', '/collections/' + collId + '/evaluate');
            const items = (evalRes.success && evalRes.data) ? evalRes.data : [];
            if (items.length > 0) {
                itemsHTML = '<div class="media-grid">' + items.map(renderMediaCard).join('') + '</div>';
            } else {
                itemsHTML = '<div class="empty-state"><div class="empty-state-icon">&#128269;</div><div class="empty-state-title">No matches</div><p>No items match the current smart rules</p></div>';
            }
        } else {
            // Manual collection items with joined metadata
            const items = coll.items || [];
            if (items.length > 0) {
                itemsHTML = '<div class="media-grid">' + items.map(ci => {
                    // Render collection item as a media card using joined metadata
                    const dur = ci.duration_seconds ? Math.floor(ci.duration_seconds / 60) + 'min' : '';
                    const year = ci.year || '';
                    const res = ci.resolution || '';
                    const meta = [year, dur, res].filter(Boolean).join(' \u00b7 ');
                    const itemId = ci.media_item_id || ci.tv_show_id || ci.album_id || ci.book_id || '';
                    const clickAction = ci.media_item_id ? `loadMediaDetail('${ci.media_item_id}')` : (ci.tv_show_id ? `loadShowView('${ci.tv_show_id}')` : '');
                    return `<div class="media-card" tabindex="0" onclick="${clickAction}">
                        <div class="media-poster" style="position:relative;">
                            ${ci.poster_path ? '<img src="' + posterSrc(ci.poster_path, coll.updated_at) + '" alt="" loading="lazy">' : '&#127916;'}
                            ${renderOverlayBadges(ci)}
                            <button class="cw-remove" onclick="event.stopPropagation();removeFromCollection('${collId}','${ci.id}')" title="Remove from collection">&#10005;</button>
                            <div class="media-card-hover-info">
                                <div class="hover-title">${ci.title || 'Untitled'}</div>
                                <div class="hover-meta">${ci.rating ? '<span class="hover-rating-badge">&#11088; ' + ci.rating.toFixed(1) + '</span>' : ''}<span>${meta}</span></div>
                            </div>
                            <div class="play-overlay"><div class="play-button">&#9654;</div></div>
                        </div>
                        <div class="media-info"><div class="media-title">${ci.title || 'Untitled'}</div><div class="media-meta">${meta}</div></div>
                    </div>`;
                }).join('') + '</div>';
            } else {
                itemsHTML = '<div class="empty-state"><div class="empty-state-icon">&#128218;</div><div class="empty-state-title">Empty collection</div><p>Add items from media detail pages using the + Collection button</p></div>';
            }
        }

        mc.innerHTML = breadcrumb + headerHTML + statsHTML + childHTML + sortHTML + itemsHTML;
    }

    async function changeCollectionSort(collId, sortMode) {
        await api('PUT', '/collections/' + collId, { item_sort_mode: sortMode });
        loadCollectionDetailView(collId);
    }

    // ──── Performers ────
    async function loadPerformersView() {
        const mc=document.getElementById('mainContent'); const isAdmin=currentUser&&currentUser.role==='admin';
        mc.innerHTML=`<div class="section-header"><h2 class="section-title">Performers</h2>${isAdmin?'<button class="btn-primary" onclick="showCreatePerformer()">+ Add Performer</button>':''}</div><div class="person-grid" id="performerGrid"><div class="spinner"></div></div>`;
        const data=await api('GET','/performers');
        const grid=document.getElementById('performerGrid');
        if(data.success&&data.data&&data.data.length>0){
            grid.innerHTML=data.data.map(p=>`<div class="person-card" onclick="loadPerformerDetail('${p.id}')"><div class="person-avatar">${p.photo_path?'<img src="'+p.photo_path+'">':'&#128100;'}</div><div class="person-name">${p.name}</div><div class="person-role">${p.performer_type} \u00b7 ${p.media_count||0} media</div></div>`).join('');
        } else grid.innerHTML='<div class="empty-state" style="grid-column:1/-1;"><div class="empty-state-icon">&#128100;</div><div class="empty-state-title">No performers</div><p>Add performers to link them to your media</p></div>';
    }

    async function loadPerformerDetail(id) {
        const mc=document.getElementById('mainContent');
        mc.innerHTML='<div class="spinner"></div> Loading...';
        const data=await api('GET','/performers/'+id);
        if(!data.success){mc.innerHTML='<div class="empty-state"><div class="empty-state-title">Performer not found</div></div>';return;}
        const p=data.data.performer; const media=data.data.media||[];
        mc.innerHTML=`<div class="detail-hero"><div class="detail-poster">${p.photo_path?'<img src="'+p.photo_path+'">':'&#128100;'}</div><div class="detail-info"><h1>${p.name}</h1><div class="meta-row">${p.performer_type}${p.birth_date?' \u00b7 Born: '+new Date(p.birth_date).toLocaleDateString():''}</div>${p.bio?'<p class="description">'+p.bio+'</p>':''}<span class="tag tag-cyan">${p.media_count||0} media items</span></div></div>
        ${media.length>0?'<h3 style="color:#00D9FF;margin-bottom:16px;">Linked Media</h3><div class="media-grid">'+media.map(renderMediaCard).join('')+'</div>':''}
        <button class="btn-secondary" onclick="loadPerformersView()">&#8592; Back</button>`;
    }

    function showCreatePerformer(){const mc=document.getElementById('mainContent');mc.innerHTML=`<div class="section-header"><h2 class="section-title">Add Performer</h2></div><div style="max-width:500px;"><div class="form-group"><label>Name</label><input type="text" id="perfName"></div><div class="form-group"><label>Type</label><select id="perfType"><option value="actor">Actor</option><option value="director">Director</option><option value="producer">Producer</option><option value="musician">Musician</option><option value="narrator">Narrator</option><option value="adult_performer">Adult Performer</option><option value="other">Other</option></select></div><div class="form-group"><label>Bio</label><textarea id="perfBio" rows="3"></textarea></div><button class="btn-primary" onclick="createPerformer()">Create</button><button class="btn-secondary" style="margin-left:12px;" onclick="loadPerformersView()">Cancel</button></div>`;}
    async function createPerformer(){const n=document.getElementById('perfName').value,t=document.getElementById('perfType').value,b=document.getElementById('perfBio').value||null;if(!n){toast('Name required','error');return;}const d=await api('POST','/performers',{name:n,performer_type:t,bio:b});if(d.success){toast('Created!');loadPerformersView();}else toast(d.error,'error');}

    // ──── Tags ────
    async function loadTagsView() {
        const mc=document.getElementById('mainContent'); const isAdmin=currentUser&&currentUser.role==='admin';
        mc.innerHTML=`<div class="section-header"><h2 class="section-title">Tags & Genres</h2>${isAdmin?'<button class="btn-primary" onclick="showCreateTag()">+ Add Tag</button>':''}</div><div id="tagsList"><div class="spinner"></div></div>`;
        const data=await api('GET','/tags?tree=true');
        const div=document.getElementById('tagsList');
        if(data.success&&data.data&&data.data.length>0){
            div.innerHTML=data.data.map(t=>renderTag(t,0)).join('');
        } else div.innerHTML='<div class="empty-state"><div class="empty-state-icon">&#127991;</div><div class="empty-state-title">No tags</div></div>';
    }

    function renderTag(tag, depth) {
        const indent = depth * 24;
        let html = `<div class="group-card" style="margin-left:${indent}px;display:flex;justify-content:space-between;align-items:center;"><div><h4>${tag.name}</h4><span class="tag tag-${tag.category==='genre'?'purple':tag.category==='custom'?'orange':'cyan'}">${tag.category}</span><span class="tag tag-green">${tag.media_count||0} media</span></div><button class="btn-danger btn-small" onclick="deleteTag('${tag.id}')">Delete</button></div>`;
        if (tag.children) tag.children.forEach(c => html += renderTag(c, depth+1));
        return html;
    }

    function showCreateTag(){const mc=document.getElementById('mainContent');mc.innerHTML=`<div class="section-header"><h2 class="section-title">Add Tag</h2></div><div style="max-width:500px;"><div class="form-group"><label>Name</label><input type="text" id="tagName"></div><div class="form-group"><label>Category</label><select id="tagCat"><option value="genre">Genre</option><option value="tag">Tag</option><option value="custom">Custom</option></select></div><div class="form-group"><label>Description</label><input type="text" id="tagDesc"></div><button class="btn-primary" onclick="createTag()">Create</button><button class="btn-secondary" style="margin-left:12px;" onclick="loadTagsView()">Cancel</button></div>`;}
    async function createTag(){const n=document.getElementById('tagName').value,c=document.getElementById('tagCat').value,d=document.getElementById('tagDesc').value||null;if(!n){toast('Name required','error');return;}const r=await api('POST','/tags',{name:n,category:c,description:d});if(r.success){toast('Created!');loadTagsView();}else toast(r.error,'error');}
    async function deleteTag(id){if(!confirm('Delete?'))return;const d=await api('DELETE','/tags/'+id);if(d.success){toast('Deleted');loadTagsView();}else toast(d.error,'error');}

    // ──── Studios ────
    async function loadStudiosView() {
        const mc=document.getElementById('mainContent'); const isAdmin=currentUser&&currentUser.role==='admin';
        mc.innerHTML=`<div class="section-header"><h2 class="section-title">Studios / Labels</h2>${isAdmin?'<button class="btn-primary" onclick="showCreateStudio()">+ Add Studio</button>':''}</div><div id="studiosList"><div class="spinner"></div></div>`;
        const data=await api('GET','/studios');
        const div=document.getElementById('studiosList');
        if(data.success&&data.data&&data.data.length>0){
            div.innerHTML=data.data.map(s=>`<div class="group-card"><div style="display:flex;justify-content:space-between;align-items:center;"><div><h4>${s.name}</h4><span class="tag tag-cyan">${s.studio_type}</span><span class="tag tag-green">${s.media_count||0} media</span></div>${isAdmin?`<button class="btn-danger btn-small" onclick="deleteStudio('${s.id}')">Delete</button>`:''}</div></div>`).join('');
        } else div.innerHTML='<div class="empty-state"><div class="empty-state-icon">&#127980;</div><div class="empty-state-title">No studios</div></div>';
    }
    function showCreateStudio(){const mc=document.getElementById('mainContent');mc.innerHTML=`<div class="section-header"><h2 class="section-title">Add Studio</h2></div><div style="max-width:500px;"><div class="form-group"><label>Name</label><input type="text" id="studioName"></div><div class="form-group"><label>Type</label><select id="studioType"><option value="studio">Studio</option><option value="label">Label</option><option value="publisher">Publisher</option><option value="network">Network</option><option value="distributor">Distributor</option></select></div><div class="form-group"><label>Website</label><input type="text" id="studioWeb"></div><button class="btn-primary" onclick="createStudio()">Create</button><button class="btn-secondary" style="margin-left:12px;" onclick="loadStudiosView()">Cancel</button></div>`;}
    async function createStudio(){const n=document.getElementById('studioName').value,t=document.getElementById('studioType').value,w=document.getElementById('studioWeb').value||null;if(!n){toast('Name required','error');return;}const d=await api('POST','/studios',{name:n,studio_type:t,website:w});if(d.success){toast('Created!');loadStudiosView();}else toast(d.error,'error');}
    async function deleteStudio(id){if(!confirm('Delete?'))return;const d=await api('DELETE','/studios/'+id);if(d.success){toast('Deleted');loadStudiosView();}else toast(d.error,'error');}

    // ──── Duplicates ────
    async function loadDuplicatesView() {
        const mc = document.getElementById('mainContent');
        mc.innerHTML = `<div class="section-header"><h2 class="section-title">Duplicate Review</h2></div>
            <p style="color:#8a9bae;margin-bottom:20px;">Review media items flagged as exact (MD5) or potential (phash) duplicates</p>
            <div id="dupList"><div class="spinner"></div></div>`;
        const data = await api('GET', '/duplicates');
        const div = document.getElementById('dupList');
        if (!data.success) { div.innerHTML = '<p style="color:#ff6b6b;">Failed to load duplicates</p>'; return; }
        const groups = data.data && data.data.groups ? data.data.groups : [];
        if (groups.length === 0) {
            div.innerHTML = '<div class="empty-state"><div class="empty-state-icon">&#128257;</div><div class="empty-state-title">No duplicates found</div><p>Scan libraries to detect duplicates via MD5 and perceptual hashing</p></div>';
            return;
        }
        div.innerHTML = groups.map(g => renderDuplicateGroup(g)).join('');
    }

    function renderDuplicateGroup(g) {
        const item = g.item;
        const typeClass = g.dup_type === 'exact' ? 'dup-type-exact' : 'dup-type-potential';
        const typeLabel = g.dup_type === 'exact' ? 'Exact Duplicate' : 'Potential Duplicate';
        const matches = g.matches || [];
        const decisions = g.decisions || [];

        let decisionsHtml = '';
        if (decisions.length > 0) {
            decisionsHtml = `<div class="dup-decisions"><strong>Prior decisions:</strong> ` +
                decisions.map(d => `${d.action} by ${d.decided_by} on ${new Date(d.decided_at).toLocaleDateString()}`
                    + (d.notes ? ' - ' + d.notes : '')).join('; ') + '</div>';
        }

        let matchesHtml = '';
        if (matches.length > 0) {
            matchesHtml = `<div class="dup-compare">` + renderDupCard(item, 'Source') +
                matches.map(m => renderDupCard(m.item, m.match_type === 'md5' ?
                    `<span class="dup-match-badge dup-match-md5">MD5 Match</span>` :
                    `<span class="dup-match-badge dup-match-phash">${Math.round(m.similarity * 100)}% Similar</span>`
                )).join('') + `</div>`;
        }

        const bestMatch = matches.length > 0 ? matches[0] : null;
        const partnerId = bestMatch ? bestMatch.item.id : '';
        const partnerTitle = bestMatch ? bestMatch.item.title : '';

        return `<div class="dup-group">
            <div class="dup-group-header">
                <h3 style="color:#e5e5e5;">${item.title}${item.year ? ' (' + item.year + ')' : ''}</h3>
                <span class="dup-type-badge ${typeClass}">${typeLabel}</span>
            </div>
            ${matchesHtml}
            ${decisionsHtml}
            <div class="dup-actions">
                <button class="btn-edit btn-small" onclick="dupEdit('${item.id}','${partnerId}')">&#9998; Edit</button>
                <button class="btn-edition btn-small" onclick="dupMergeEdition('${item.id}','${partnerId}','${item.title.replace(/'/g,"\\'")}','${partnerTitle.replace(/'/g,"\\'")}')">&#128191; Merge as Edition</button>
                <button class="btn-danger btn-small" onclick="dupDelete('${item.id}','${partnerId}')">&#128465; Delete</button>
                <button class="btn-secondary btn-small" onclick="dupIgnore('${item.id}','${partnerId}')">&#128683; Ignore</button>
            </div>
        </div>`;
    }

    function renderDupCard(item, label) {
        const fileSize = item.file_size ? (item.file_size / (1024*1024*1024)).toFixed(2) + ' GB' : '';
        const res = item.resolution || '';
        const filePath = item.file_path || '';
        const shortPath = filePath.length > 60 ? '...' + filePath.slice(-57) : filePath;
        return `<div class="dup-card">
            <div class="dup-card-header">
                <div class="dup-card-poster">${item.poster_path ? '<img src="'+posterSrc(item.poster_path, item.updated_at)+'">' : '<div style="display:flex;align-items:center;justify-content:center;height:100%;font-size:2rem;color:#4a5568;">&#127910;</div>'}</div>
                <div class="dup-card-meta">
                    <h4>${item.title}</h4>
                    <p>${item.year || 'N/A'}${res ? ' &middot; ' + res : ''}${fileSize ? ' &middot; ' + fileSize : ''}</p>
                    <p title="${filePath}" style="word-break:break-all;">${shortPath}</p>
                    <div style="margin-top:6px;">${label}</div>
                </div>
            </div>
        </div>`;
    }

    async function dupEdit(itemId, partnerId) {
        // Open the edit modal, then mark as addressed on save
        openEditModal(itemId);
        // After save, mark both as addressed
        window._dupResolveAfterEdit = { itemId, partnerId };
    }

    async function dupIgnore(itemId, partnerId) {
        const d = await api('POST', '/duplicates/resolve', { media_id: itemId, partner_id: partnerId, action: 'ignored' });
        if (d.success) { toast('Marked as ignored'); loadDuplicatesView(); loadSidebarCounts(); } else toast(d.error, 'error');
    }

    async function dupDelete(itemId, partnerId) {
        if (!confirm('Delete this item from the database?')) return;
        const deleteFile = confirm('Also delete the file from disk? (Cannot be undone)');
        const d = await api('POST', '/duplicates/resolve', { media_id: itemId, partner_id: partnerId, action: 'deleted', delete_file: deleteFile });
        if (d.success) { toast('Item deleted'); loadDuplicatesView(); loadSidebarCounts(); } else toast(d.error, 'error');
    }

    function dupMergeEdition(itemA, itemB, titleA, titleB) {
        document.getElementById('mergeItemA').value = itemA;
        document.getElementById('mergeItemB').value = itemB;
        const opts = document.getElementById('mergePrimaryOptions');
        opts.innerHTML = `
            <div class="merge-option selected" onclick="selectMergePrimary(this,'${itemA}')">
                <label><input type="radio" name="mergePrimary" value="${itemA}" checked> ${titleA} (Source)</label>
            </div>
            <div class="merge-option" onclick="selectMergePrimary(this,'${itemB}')">
                <label><input type="radio" name="mergePrimary" value="${itemB}"> ${titleB} (Match)</label>
            </div>`;
        document.getElementById('mergeEditionOverlay').classList.add('active');
    }

    function selectMergePrimary(el, id) {
        document.querySelectorAll('.merge-option').forEach(o => o.classList.remove('selected'));
        el.classList.add('selected');
        el.querySelector('input[type="radio"]').checked = true;
    }

    function closeMergeModal() {
        document.getElementById('mergeEditionOverlay').classList.remove('active');
    }

    async function submitMergeEdition() {
        const itemA = document.getElementById('mergeItemA').value;
        const itemB = document.getElementById('mergeItemB').value;
        const label = document.getElementById('mergeEditionLabel').value;
        const primaryId = document.querySelector('input[name="mergePrimary"]:checked').value;
        const d = await api('POST', '/duplicates/resolve', {
            media_id: itemA, partner_id: itemB, action: 'edition',
            edition_label: label, primary_id: primaryId
        });
        if (d.success) { toast('Merged as edition!'); closeMergeModal(); loadDuplicatesView(); loadSidebarCounts(); }
        else toast(d.error, 'error');
    }

    // Close merge modal on overlay click
    document.getElementById('mergeEditionOverlay').addEventListener('click', function(e) {
        if (e.target === this) closeMergeModal();
    });

    // ──── Metadata Identify ────
    let _identifyMatches = [];
    let _identifyMediaId = '';

    async function identifyMedia(id) {
        const mc=document.getElementById('mainContent');
        mc.innerHTML='<div class="section-header"><h2 class="section-title">Identify Media</h2></div><div id="matchList"><div class="spinner"></div> Searching external sources...</div>';
        const data=await api('POST','/media/'+id+'/identify');
        const div=document.getElementById('matchList');
        _identifyMediaId = id;
        _identifyMatches = (data.success && data.data) ? data.data : [];
        if(_identifyMatches.length>0){
            const esc = (s) => s ? s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;') : '';
            div.innerHTML=_identifyMatches.map((m,i)=>`<div class="group-card"><div style="display:flex;gap:16px;align-items:start;"><div style="width:80px;min-width:80px;aspect-ratio:2/3;border-radius:10px;overflow:hidden;background:rgba(0,0,0,0.3);">${m.poster_url?'<img src="'+m.poster_url+'" style="width:100%;height:100%;object-fit:cover;">':'&#128247;'}</div><div><h4>${esc(m.title)}${m.year?' ('+m.year+')':''}</h4><p>${m.description?esc(m.description.substring(0,200))+'...':''}</p><span class="tag tag-cyan">${m.source}</span><span class="tag tag-green">${Math.round(m.confidence*100)}% match</span><button class="btn-primary btn-small" style="margin-top:8px;" onclick="applyMatchByIndex(${i})">Apply</button></div></div></div>`).join('');
        } else div.innerHTML='<div class="empty-state"><div class="empty-state-title">No matches found</div></div>';
        div.innerHTML+='<button class="btn-secondary" style="margin-top:16px;" onclick="loadMediaDetail(\''+id+'\')">&#8592; Back</button>';
    }

    async function applyMatchByIndex(idx) {
        const match = _identifyMatches[idx];
        if (!match) { toast('Match not found','error'); return; }
        const d=await api('POST','/media/'+_identifyMediaId+'/apply-meta',match);
        if(d.success){toast('Metadata applied!');loadMediaDetail(_identifyMediaId);}else toast(d.error,'error');
    }

    // ──── Edit Media ────
    async function openEditModal(id) {
        const data = await api('GET', '/media/' + id);
        if (!data.success) { toast('Failed to load media', 'error'); return; }
        const m = data.data;
        document.getElementById('editMediaId').value = m.id;
        document.getElementById('editTitle').value = m.title || '';
        document.getElementById('editSortTitle').value = m.sort_title || '';
        document.getElementById('editOriginalTitle').value = m.original_title || '';
        document.getElementById('editDescription').value = m.description || '';
        document.getElementById('editYear').value = m.year || '';
        document.getElementById('editReleaseDate').value = m.release_date ? m.release_date.substring(0,10) : '';
        document.getElementById('editRating').value = m.rating != null ? m.rating : '';
        // Edition type (always shown)
        document.getElementById('editEditionType').value = m.edition_type || 'Theatrical';
        // Poster and backdrop
        document.getElementById('editPosterPath').value = m.poster_path || '';
        document.getElementById('editBackdropPath').value = m.backdrop_path || '';
        // Custom notes and tags
        document.getElementById('editCustomNotes').value = m.custom_notes || '';
        const ctRaw = m.custom_tags ? (typeof m.custom_tags === 'string' ? JSON.parse(m.custom_tags || '{}') : m.custom_tags) : {};
        const ctArr = ctRaw.tags || [];
        document.getElementById('editCustomTags').value = ctArr.join(', ');
        // Cast display
        document.getElementById('editCastPanel').style.display = 'none';
        document.getElementById('editCastToggle').classList.remove('open');
        loadEditCast(m.id);
        // Parent Movie field (movies and adult_movies only)
        const parentGroup = document.getElementById('parentMovieGroup');
        const parentSearch = document.getElementById('parentMovieSearch');
        const parentIdField = document.getElementById('parentMovieId');
        const parentInfo = document.getElementById('parentCurrentInfo');
        parentSearch.value = '';
        parentIdField.value = '';
        parentInfo.style.display = 'none';
        parentInfo.innerHTML = '';
        document.getElementById('parentSearchResults').classList.remove('active');
        if (m.media_type === 'movies' || m.media_type === 'adult_movies') {
            parentGroup.style.display = '';
            // Check if already in an edition group
            const edRes = await api('GET', '/media/' + id + '/editions');
            if (edRes.success && edRes.data.has_editions) {
                const eds = edRes.data.editions || [];
                const parent = eds.find(e => e.is_default);
                if (parent && parent.media_item_id !== m.id) {
                    parentInfo.style.display = '';
                    parentInfo.innerHTML = `<div class="parent-current"><span class="pc-title">&#128279; Parent: ${parent.title} (${parent.edition_type})</span><button class="pc-remove" onclick="removeEditionParent('${m.id}')">Remove</button></div>`;
                } else if (parent && parent.media_item_id === m.id && eds.length > 1) {
                    parentInfo.style.display = '';
                    parentInfo.innerHTML = `<div class="parent-current"><span class="pc-title">&#11088; This is the parent movie (${eds.length} editions)</span></div>`;
                }
            }
        } else {
            parentGroup.style.display = 'none';
        }
        // Series info (movies and adult_movies only)
        const seriesGroup = document.getElementById('editSeriesGroup');
        const seriesInfo = document.getElementById('editSeriesInfo');
        seriesInfo.innerHTML = '';
        if (m.media_type === 'movies' || m.media_type === 'adult_movies') {
            seriesGroup.style.display = '';
            loadEditSeriesInfo(m.id);
        } else {
            seriesGroup.style.display = 'none';
        }
        // Lock status & per-field locks
        const lockedFields = m.locked_fields || [];
        renderFieldLocks(lockedFields);
        // Collapse the field locks panel by default
        document.getElementById('fieldLocksPanel').style.display = 'none';
        document.getElementById('fieldLocksToggle').classList.remove('open');

        const lockDiv = document.getElementById('editLockStatus');
        const resetBtn = document.getElementById('editResetBtn');
        if (m.metadata_locked || lockedFields.includes('*')) {
            lockDiv.innerHTML = '<span class="lock-badge locked">&#128274; All fields locked — auto-match will not overwrite your edits</span>';
            resetBtn.style.display = 'inline-flex';
        } else if (lockedFields.length > 0) {
            lockDiv.innerHTML = '<span class="lock-badge locked">&#128274; ' + lockedFields.length + ' field' + (lockedFields.length > 1 ? 's' : '') + ' locked</span>';
            resetBtn.style.display = 'inline-flex';
        } else {
            lockDiv.innerHTML = '<span class="lock-badge unlocked">&#128275; No fields locked — auto-match may update all fields</span>';
            resetBtn.style.display = 'none';
        }
        document.getElementById('editMediaOverlay').classList.add('active');
    }

    function closeEditModal() {
        document.getElementById('editMediaOverlay').classList.remove('active');
    }

    async function saveMediaEdit() {
        const id = document.getElementById('editMediaId').value;
        const title = document.getElementById('editTitle').value.trim();
        if (!title) { toast('Title is required', 'error'); return; }
        const sortTitle = document.getElementById('editSortTitle').value.trim() || null;
        const originalTitle = document.getElementById('editOriginalTitle').value.trim() || null;
        const description = document.getElementById('editDescription').value.trim() || null;
        const yearVal = document.getElementById('editYear').value;
        const year = yearVal ? parseInt(yearVal) : null;
        const releaseDate = document.getElementById('editReleaseDate').value || null;
        const ratingVal = document.getElementById('editRating').value;
        const rating = ratingVal !== '' ? parseFloat(ratingVal) : null;

        const editionType = document.getElementById('editEditionType').value;
        const posterPath = document.getElementById('editPosterPath').value.trim() || null;
        const backdropPath = document.getElementById('editBackdropPath').value.trim() || null;
        const customNotes = document.getElementById('editCustomNotes').value.trim() || null;
        const ctInput = document.getElementById('editCustomTags').value.trim();
        const ctTags = ctInput ? ctInput.split(',').map(t => t.trim()).filter(Boolean) : [];
        const customTags = JSON.stringify({ tags: ctTags });

        const d = await api('PUT', '/media/' + id, {
            title, sort_title: sortTitle, original_title: originalTitle,
            description, year, release_date: releaseDate, rating,
            edition_type: editionType, poster_path: posterPath, backdrop_path: backdropPath,
            custom_notes: customNotes, custom_tags: customTags
        });
        if (d.success) {
            // Set edition parent if one was selected
            const parentId = document.getElementById('parentMovieId').value;
            if (parentId) {
                await api('POST', '/media/' + id + '/edition-parent', {
                    parent_id: parentId,
                    edition_type: editionType
                });
            }
            toast('Changes saved! Metadata locked.');
            closeEditModal();
            // If triggered from duplicate review, mark as addressed
            if (window._dupResolveAfterEdit) {
                const r = window._dupResolveAfterEdit;
                await api('POST', '/duplicates/resolve', { media_id: r.itemId, partner_id: r.partnerId, action: 'edit' });
                window._dupResolveAfterEdit = null;
                loadDuplicatesView();
                loadSidebarCounts();
            } else {
                loadMediaDetail(id);
            }
        } else {
            toast(d.error || 'Save failed', 'error');
        }
    }

    async function resetMediaMeta() {
        const id = document.getElementById('editMediaId').value;
        if (!confirm('Reset all metadata locks? The next auto-match or scan will be able to overwrite your edits.')) return;
        // Clear per-field locks as well
        await api('PUT', '/media/' + id + '/locked-fields', { locked_fields: [] });
        const d = await api('POST', '/media/' + id + '/reset');
        if (d.success) {
            toast('All metadata locks removed');
            closeEditModal();
            loadMediaDetail(id);
        } else {
            toast(d.error || 'Reset failed', 'error');
        }
    }

    // ──── Per-Field Locks ────
    const LOCKABLE_FIELDS = [
        { key: 'title', label: 'Title' },
        { key: 'description', label: 'Description' },
        { key: 'year', label: 'Year' },
        { key: 'rating', label: 'Rating' },
        { key: 'poster_path', label: 'Poster' },
        { key: 'content_rating', label: 'Content Rating' },
        { key: 'tagline', label: 'Tagline' },
        { key: 'original_language', label: 'Language' },
        { key: 'country', label: 'Country' },
        { key: 'trailer_url', label: 'Trailer' },
        { key: 'logo_path', label: 'Logo' },
        { key: 'backdrop_path', label: 'Backdrop' },
        { key: 'imdb_rating', label: 'IMDb Rating' },
        { key: 'rt_rating', label: 'RT Score' },
        { key: 'audience_score', label: 'Audience Score' },
        { key: 'genres', label: 'Genres' },
        { key: 'cast', label: 'Cast & Crew' },
        { key: 'source_type', label: 'Source Type' },
        { key: 'hdr_format', label: 'HDR Format' },
        { key: 'custom_notes', label: 'Custom Notes' },
        { key: 'custom_tags', label: 'Custom Tags' },
    ];
    let _currentLockedFields = [];

    function toggleFieldLocks() {
        const panel = document.getElementById('fieldLocksPanel');
        const toggle = document.getElementById('fieldLocksToggle');
        const isOpen = panel.style.display !== 'none';
        panel.style.display = isOpen ? 'none' : '';
        toggle.classList.toggle('open', !isOpen);
    }

    function renderFieldLocks(lockedFields) {
        _currentLockedFields = lockedFields || [];
        const grid = document.getElementById('fieldLocksGrid');
        const hasWildcard = _currentLockedFields.includes('*');
        grid.innerHTML = LOCKABLE_FIELDS.map(f => {
            const isLocked = hasWildcard || _currentLockedFields.includes(f.key);
            return `<div class="field-lock-item">
                <label onclick="toggleFieldLock('${f.key}')">${f.label}</label>
                <span class="field-lock-icon ${isLocked ? 'locked' : 'unlocked'}" onclick="toggleFieldLock('${f.key}')"
                    title="${isLocked ? 'Locked — click to unlock' : 'Unlocked — click to lock'}">
                    ${isLocked ? '&#128274;' : '&#128275;'}
                </span>
            </div>`;
        }).join('');
    }

    async function toggleFieldLock(fieldKey) {
        const id = document.getElementById('editMediaId').value;
        // Remove wildcard if present (switching to per-field mode)
        let fields = _currentLockedFields.filter(f => f !== '*');
        const idx = fields.indexOf(fieldKey);
        if (idx >= 0) {
            fields.splice(idx, 1);
        } else {
            fields.push(fieldKey);
        }
        // Save to API
        const d = await api('PUT', '/media/' + id + '/locked-fields', { locked_fields: fields });
        if (d.success) {
            _currentLockedFields = fields;
            renderFieldLocks(fields);
            // Update lock status display
            updateLockStatusDisplay(fields);
        } else {
            toast(d.error || 'Failed to update field lock', 'error');
        }
    }

    function updateLockStatusDisplay(fields) {
        const lockDiv = document.getElementById('editLockStatus');
        const resetBtn = document.getElementById('editResetBtn');
        if (fields.includes('*') || fields.length === LOCKABLE_FIELDS.length) {
            lockDiv.innerHTML = '<span class="lock-badge locked">&#128274; All fields locked</span>';
            resetBtn.style.display = 'inline-flex';
        } else if (fields.length > 0) {
            lockDiv.innerHTML = '<span class="lock-badge locked">&#128274; ' + fields.length + ' field' + (fields.length > 1 ? 's' : '') + ' locked</span>';
            resetBtn.style.display = 'inline-flex';
        } else {
            lockDiv.innerHTML = '<span class="lock-badge unlocked">&#128275; No fields locked — auto-match may update all fields</span>';
            resetBtn.style.display = 'none';
        }
    }

    // ──── Edit Modal Cast Display ────
    function toggleEditCast() {
        const panel = document.getElementById('editCastPanel');
        const toggle = document.getElementById('editCastToggle');
        const isOpen = panel.style.display !== 'none';
        panel.style.display = isOpen ? 'none' : '';
        toggle.classList.toggle('open', !isOpen);
    }

    async function loadEditCast(mediaId) {
        const panel = document.getElementById('editCastPanel');
        const castRes = await api('GET', '/media/' + mediaId + '/cast');
        if (castRes.success && castRes.data && castRes.data.length > 0) {
            const castItems = castRes.data.map(c => {
                const subtitle = c.role === 'actor' ? (c.character_name || 'Actor') : c.role;
                return `<div style="display:flex;align-items:center;gap:10px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.05);">
                    <div style="width:32px;height:32px;border-radius:50%;background:rgba(0,217,255,0.15);display:flex;align-items:center;justify-content:center;font-size:0.7rem;flex-shrink:0;">
                        ${c.photo_path ? '<img src="'+c.photo_path+'" style="width:32px;height:32px;border-radius:50%;object-fit:cover;">' : '&#128100;'}
                    </div>
                    <div style="flex:1;min-width:0;">
                        <div style="font-size:0.82rem;color:#e5e5e5;">${c.name}</div>
                        <div style="font-size:0.72rem;color:#5a6a7f;">${subtitle}</div>
                    </div>
                </div>`;
            }).join('');
            panel.innerHTML = `<div style="max-height:200px;overflow-y:auto;padding:8px 0;">${castItems}</div>
                <p style="font-size:0.72rem;color:#6b7b8d;margin-top:6px;">Cast is populated via metadata matching. Use Identify to refresh.</p>`;
        } else {
            panel.innerHTML = '<p style="color:#5a6a7f;font-size:0.82rem;padding:8px 0;">No cast data. Use Identify to populate from metadata sources.</p>';
        }
    }

    // ──── Parent Movie Search ────
    let _parentSearchTimer = null;
    function searchParentMovie(query) {
        clearTimeout(_parentSearchTimer);
        const results = document.getElementById('parentSearchResults');
        if (query.length < 2) { results.classList.remove('active'); return; }
        _parentSearchTimer = setTimeout(async () => {
            const d = await api('GET', '/media/search?q=' + encodeURIComponent(query));
            if (!d.success || !d.data || d.data.length === 0) { results.classList.remove('active'); return; }
            const editId = document.getElementById('editMediaId').value;
            const items = d.data.filter(i => i.id !== editId && (i.media_type === 'movies' || i.media_type === 'adult_movies'));
            if (items.length === 0) { results.classList.remove('active'); return; }
            results.innerHTML = items.slice(0, 10).map(i =>
                `<div class="parent-search-result" onclick="selectParentMovie('${i.id}','${i.title.replace(/'/g,"\\'")}',${i.year||'null'})">${i.title}<span class="psr-year">${i.year||''}</span></div>`
            ).join('');
            results.classList.add('active');
        }, 300);
    }

    function selectParentMovie(id, title, year) {
        document.getElementById('parentMovieId').value = id;
        document.getElementById('parentMovieSearch').value = '';
        document.getElementById('parentSearchResults').classList.remove('active');
        const info = document.getElementById('parentCurrentInfo');
        info.style.display = '';
        info.innerHTML = `<div class="parent-current"><span class="pc-title">&#128279; Parent: ${title}${year ? ' ('+year+')' : ''}</span><button class="pc-remove" onclick="clearParentSelection()">Remove</button></div>`;
    }

    function clearParentSelection() {
        document.getElementById('parentMovieId').value = '';
        document.getElementById('parentCurrentInfo').style.display = 'none';
        document.getElementById('parentCurrentInfo').innerHTML = '';
    }

    async function removeEditionParent(mediaId) {
        if (!confirm('Remove this movie from its edition group?')) return;
        const d = await api('DELETE', '/media/' + mediaId + '/edition-parent');
        if (d.success) {
            toast('Removed from edition group');
            closeEditModal();
            loadMediaDetail(mediaId);
        } else {
            toast(d.error || 'Failed to remove', 'error');
        }
    }

    // Close parent search on click outside
    document.addEventListener('click', function(e) {
        const wrap = document.querySelector('.parent-search-wrap');
        if (wrap && !wrap.contains(e.target)) {
            document.getElementById('parentSearchResults').classList.remove('active');
        }
    });

    // Close edit modal on Escape
    document.getElementById('editMediaOverlay').addEventListener('click', function(e) {
        if (e.target === this) closeEditModal();
    });

    // ──── Movie Series ────
    let _seriesLibraryList = [];

    async function showLibrarySeries() {
        const libId = _gridState.libraryId;
        if (!libId) return;

        const wrapper = document.getElementById('mediaGridWrapper');
        const collArea = document.getElementById('collectionsArea');
        const serArea = document.getElementById('seriesArea');
        if (wrapper) wrapper.style.display = 'none';
        if (collArea) collArea.style.display = 'none';
        if (serArea) serArea.style.display = 'block';

        const gridBtn = document.getElementById('ftGridBtn');
        const collBtn = document.getElementById('ftCollBtn');
        const serBtn = document.getElementById('ftSeriesBtn');
        if (gridBtn) gridBtn.classList.remove('active');
        if (collBtn) collBtn.classList.remove('active');
        if (serBtn) serBtn.classList.add('active');

        serArea.innerHTML = '<div class="spinner"></div> Loading series...';
        const data = await api('GET', '/series?library_id=' + libId);
        const seriesList = (data.success && data.data) ? data.data : [];

        if (seriesList.length === 0) {
            serArea.innerHTML = '<div class="empty-state"><div class="empty-state-icon">&#127910;</div><div class="empty-state-title">No series</div><p>Add movies to a series from the edit modal</p></div>';
            return;
        }

        serArea.innerHTML = '<div class="series-grid">' + seriesList.map(s => {
            const poster = s.poster_path
                ? `<img src="${posterSrc(s.poster_path, s.updated_at)}" alt="">`
                : '&#127910;';
            return `<div class="series-card" onclick="loadSeriesDetail('${s.id}')">
                <div class="sc-poster">${poster}</div>
                <div class="sc-info">
                    <div class="sc-name">${s.name}</div>
                    <div class="sc-meta">${s.item_count || 0} movie${(s.item_count||0) !== 1 ? 's' : ''}</div>
                </div>
            </div>`;
        }).join('') + '</div>';
    }

    async function loadSeriesDetail(seriesId) {
        const mc = document.getElementById('mainContent');
        mc.innerHTML = '<div class="spinner"></div> Loading...';
        const data = await api('GET', '/series/' + seriesId);
        if (!data.success) { mc.innerHTML = '<div class="empty-state"><div class="empty-state-title">Series not found</div></div>'; return; }
        const s = data.data;
        const items = s.items || [];

        mc.innerHTML = `
            <div class="series-detail-header">
                <h2>${s.name}</h2>
                <span class="tag tag-cyan">${items.length} movie${items.length !== 1 ? 's' : ''}</span>
                <div class="series-detail-actions">
                    <button class="btn-danger" onclick="deleteSeries('${s.id}')">&#128465; Delete Series</button>
                </div>
            </div>
            <div class="series-movie-list" id="seriesMovieList">
                ${items.length === 0 ? '<div class="empty-state"><p>No movies in this series yet</p></div>' :
                items.map(item => `<div class="series-movie-item" onclick="loadMediaDetail('${item.media_item_id}')">
                    <div class="smi-order">${item.sort_order}</div>
                    <div class="smi-poster">${item.poster_path ? '<img src="'+posterSrc(item.poster_path, '')+'">' : '&#127910;'}</div>
                    <div class="smi-info">
                        <div class="smi-title">${item.title}</div>
                        <div class="smi-year">${item.year || ''}</div>
                    </div>
                    <button class="smi-remove" onclick="event.stopPropagation();removeFromSeries('${s.id}','${item.id}')" title="Remove from series">&#10005;</button>
                </div>`).join('')}
            </div>
            <button class="btn-secondary" style="margin-top:20px;" onclick="navigate('library','${s.library_id}')">&#8592; Back to Library</button>`;
    }

    async function deleteSeries(seriesId) {
        if (!confirm('Delete this series? Movies will not be deleted.')) return;
        const d = await api('DELETE', '/series/' + seriesId);
        if (d.success) {
            toast('Series deleted');
            history.back();
        } else {
            toast(d.error || 'Failed to delete', 'error');
        }
    }

    async function removeFromSeries(seriesId, itemId) {
        if (!confirm('Remove this movie from the series?')) return;
        const d = await api('DELETE', '/series/' + seriesId + '/items/' + itemId);
        if (d.success) {
            toast('Removed from series');
            loadSeriesDetail(seriesId);
        } else {
            toast(d.error || 'Failed to remove', 'error');
        }
    }

    // ── Add to Series Modal ──
    function openSeriesModal() {
        const mediaId = document.getElementById('editMediaId').value;
        document.getElementById('seriesMediaId').value = mediaId;
        document.getElementById('seriesNameInput').value = '';
        document.getElementById('seriesSelectedId').value = '';
        document.getElementById('seriesOrderInput').value = '1';

        // Load series list for this library
        const libId = _gridState.libraryId;
        if (libId) {
            api('GET', '/series?library_id=' + libId).then(data => {
                _seriesLibraryList = (data.success && data.data) ? data.data : [];
                renderSeriesDropdown(_seriesLibraryList);
            });
        }

        document.getElementById('seriesModalOverlay').classList.add('active');
    }

    function closeSeriesModal() {
        document.getElementById('seriesModalOverlay').classList.remove('active');
        document.getElementById('seriesDropdown').style.display = 'none';
    }

    function renderSeriesDropdown(list) {
        const dd = document.getElementById('seriesDropdown');
        if (list.length === 0) {
            dd.innerHTML = '<div style="padding:10px 14px;color:#5a6a7f;font-size:0.82rem;">No existing series — type a name to create one</div>';
        } else {
            dd.innerHTML = list.map(s =>
                `<div style="padding:10px 14px;color:#b8c5d6;font-size:0.85rem;cursor:pointer;transition:background 0.15s;" onmouseenter="this.style.background='rgba(0,217,255,0.1)'" onmouseleave="this.style.background='none'" onclick="selectSeriesOption('${s.id}','${s.name.replace(/'/g,"\\'")}')">${s.name} <span style="color:#5a6a7f;font-size:0.75rem;">(${s.item_count||0} movies)</span></div>`
            ).join('');
        }
    }

    function showSeriesDropdown() {
        const dd = document.getElementById('seriesDropdown');
        renderSeriesDropdown(_seriesLibraryList);
        dd.style.display = 'block';
    }

    function filterSeriesDropdown(query) {
        const dd = document.getElementById('seriesDropdown');
        document.getElementById('seriesSelectedId').value = '';
        if (!query.trim()) {
            renderSeriesDropdown(_seriesLibraryList);
            dd.style.display = 'block';
            return;
        }
        const filtered = _seriesLibraryList.filter(s => s.name.toLowerCase().includes(query.toLowerCase()));
        if (filtered.length === 0) {
            dd.innerHTML = '<div style="padding:10px 14px;color:#00D9FF;font-size:0.82rem;">&#10010; Create "' + query + '"</div>';
        } else {
            renderSeriesDropdown(filtered);
        }
        dd.style.display = 'block';
    }

    function selectSeriesOption(id, name) {
        document.getElementById('seriesNameInput').value = name;
        document.getElementById('seriesSelectedId').value = id;
        document.getElementById('seriesDropdown').style.display = 'none';
    }

    async function saveToSeries() {
        const mediaId = document.getElementById('seriesMediaId').value;
        const name = document.getElementById('seriesNameInput').value.trim();
        let seriesId = document.getElementById('seriesSelectedId').value;
        const sortOrder = parseInt(document.getElementById('seriesOrderInput').value) || 1;

        if (!name) { toast('Series name is required', 'error'); return; }

        // If no existing series selected, create a new one
        if (!seriesId) {
            const libId = _gridState.libraryId;
            if (!libId) { toast('Library not found', 'error'); return; }
            const createRes = await api('POST', '/series', { library_id: libId, name: name });
            if (!createRes.success) { toast(createRes.error || 'Failed to create series', 'error'); return; }
            seriesId = createRes.data.id;
        }

        // Add the movie to the series
        const addRes = await api('POST', '/series/' + seriesId + '/items', {
            media_item_id: mediaId,
            sort_order: sortOrder
        });
        if (addRes.success) {
            toast('Added to series "' + name + '"');
            closeSeriesModal();
            // Refresh edit modal series info
            loadEditSeriesInfo(mediaId);
        } else {
            toast(addRes.error || 'Failed to add to series', 'error');
        }
    }

    async function loadEditSeriesInfo(mediaId) {
        const seriesGroup = document.getElementById('editSeriesGroup');
        const seriesInfo = document.getElementById('editSeriesInfo');
        const data = await api('GET', '/media/' + mediaId + '/series');
        if (data.success && data.data && data.data.in_series) {
            const s = data.data;
            seriesInfo.innerHTML = `<div class="series-current-info"><span class="sci-name">&#127910; ${s.series.name} — #${s.sort_order}</span><button class="sci-remove" onclick="removeMediaFromSeries('${s.series.id}','${s.item_id}','${mediaId}')">Remove</button></div>`;
        } else {
            seriesInfo.innerHTML = '';
        }
    }

    async function removeMediaFromSeries(seriesId, itemId, mediaId) {
        if (!confirm('Remove this movie from the series?')) return;
        const d = await api('DELETE', '/series/' + seriesId + '/items/' + itemId);
        if (d.success) {
            toast('Removed from series');
            loadEditSeriesInfo(mediaId);
        } else {
            toast(d.error || 'Failed to remove', 'error');
        }
    }

    // Close series dropdown on click outside
    document.addEventListener('click', function(e) {
        const dd = document.getElementById('seriesDropdown');
        const inp = document.getElementById('seriesNameInput');
        if (dd && inp && !dd.contains(e.target) && e.target !== inp) {
            dd.style.display = 'none';
        }
    });

    // Close series modal on overlay click
    document.getElementById('seriesModalOverlay').addEventListener('click', function(e) {
        if (e.target === this) closeSeriesModal();
    });

    // ──── Edit Profile ────
    async function loadProfileView() {
        const mc = document.getElementById('mainContent');
        mc.innerHTML = `<div class="section-header"><h2 class="section-title">Edit Profile</h2></div><div class="settings-grid" id="profileGrid"><div class="spinner"></div></div>`;

        const profileData = await api('GET', '/profile');
        if (!profileData.success) { mc.innerHTML = '<div class="empty-state"><div class="empty-state-title">Failed to load profile</div></div>'; return; }
        const u = profileData.data;

        // Get PIN length setting for validation
        let pinLength = 4;
        try {
            const flSettings = await api('GET', '/auth/fast-login/settings');
            if (flSettings.success && flSettings.data) pinLength = parseInt(flSettings.data.fast_login_pin_length) || 4;
        } catch(e) {}

        document.getElementById('profileGrid').innerHTML = `
            <div class="settings-card">
                <h3>Personal Information</h3>
                <div class="form-group"><label>Username</label><input type="text" value="${u.username || ''}" disabled style="opacity:0.6;cursor:not-allowed;"></div>
                <div class="edit-field-row">
                    <div class="form-group"><label>First Name</label><input type="text" id="profFirstName" value="${u.first_name || ''}" placeholder="Enter first name"></div>
                    <div class="form-group"><label>Last Name</label><input type="text" id="profLastName" value="${u.last_name || ''}" placeholder="Enter last name"></div>
                </div>
                <div class="form-group"><label>Email</label><input type="email" id="profEmail" value="${u.email || ''}" placeholder="Enter email"></div>
                <button class="btn-primary" onclick="saveProfile()">Save Changes</button>
            </div>
            <div class="settings-card">
                <h3>Security</h3>
                <div class="form-group">
                    <label>New Password</label>
                    <input type="password" id="profPassword" placeholder="Leave blank to keep current">
                </div>
                <div class="form-group">
                    <label>Confirm Password</label>
                    <input type="password" id="profPasswordConfirm" placeholder="Confirm new password">
                </div>
                <button class="btn-primary" onclick="saveProfilePassword()" style="margin-bottom:20px;">Change Password</button>
                <div style="border-top:1px solid rgba(0,217,255,0.1);padding-top:16px;margin-top:4px;">
                    <h3 style="margin-bottom:12px;">Login PIN</h3>
                    <p style="color:#8a9bae;font-size:0.82rem;margin-bottom:12px;">Set a ${pinLength}-digit PIN for quick login. ${u.has_pin ? '<span style="color:#51cf66;">PIN is set.</span>' : '<span style="color:#5a6a7f;">No PIN set.</span>'}</p>
                    <div class="form-group">
                        <label>New PIN (${pinLength} digits)</label>
                        <input type="password" id="profPin" placeholder="Enter ${pinLength}-digit PIN" maxlength="${pinLength}" pattern="[0-9]*" inputmode="numeric">
                    </div>
                    <button class="btn-primary" onclick="saveProfilePin(${pinLength})">Set PIN</button>
                </div>
            </div>`;
    }

    async function saveProfile() {
        const body = {
            first_name: document.getElementById('profFirstName').value.trim(),
            last_name: document.getElementById('profLastName').value.trim(),
            email: document.getElementById('profEmail').value.trim()
        };
        if (!body.email) { toast('Email is required', 'error'); return; }
        const d = await api('PUT', '/profile', body);
        if (d.success) {
            toast('Profile updated!');
            // Update local user data
            currentUser = { ...currentUser, ...d.data };
            localStorage.setItem('user', JSON.stringify(currentUser));
        } else toast(d.error || 'Failed to update profile', 'error');
    }

    async function saveProfilePassword() {
        const pw = document.getElementById('profPassword').value;
        const pwc = document.getElementById('profPasswordConfirm').value;
        if (!pw) { toast('Please enter a new password', 'error'); return; }
        if (pw !== pwc) { toast('Passwords do not match', 'error'); return; }
        if (pw.length < 4) { toast('Password must be at least 4 characters', 'error'); return; }
        const d = await api('PUT', '/profile', { password: pw });
        if (d.success) {
            toast('Password updated!');
            document.getElementById('profPassword').value = '';
            document.getElementById('profPasswordConfirm').value = '';
        } else toast(d.error || 'Failed to update password', 'error');
    }

    async function saveProfilePin(pinLength) {
        const pin = document.getElementById('profPin').value;
        if (!pin || pin.length !== pinLength) { toast(`PIN must be exactly ${pinLength} digits`, 'error'); return; }
        if (!/^\d+$/.test(pin)) { toast('PIN must contain only digits', 'error'); return; }
        const d = await api('PUT', '/auth/pin', { pin });
        if (d.success) {
            toast('PIN updated!');
            document.getElementById('profPin').value = '';
            loadProfileView(); // Refresh to show updated PIN status
        } else toast(d.error || 'Failed to set PIN', 'error');
    }

    // ──── Settings (moved to settings.html) ────

    // Analytics + Admin moved to settings.html

    // ──── Video Player ────
    // Plex-style streaming:
    // - Native formats (MP4/WebM): served directly with range requests (native seeking)
    // - Non-native formats (MKV/AVI): remuxed to MPEG-TS on-the-fly via FFmpeg pipe
    //   Video copied as-is, audio transcoded to AAC if needed. mpegts.js handles playback.
    // - Seeking in MPEGTS streams: restart stream with ?start= parameter
    let currentStreamInfo = null;
    let currentPlayMode = null; // 'direct', 'mpegts', 'hls'
    let knownDuration = 0; // Total duration from DB
    let seekOffset = 0; // FFmpeg -ss offset for MPEGTS streams

    // ── Skip Segment State ──
    let currentSegments = [];     // MediaSegment[] for current media
    let activeSegment = null;     // Currently active segment (user is inside it)
    let skipPrefs = null;         // UserSkipPreference
    let skipPrefsLoaded = false;

    // Load user skip preferences (cached for session)
    async function loadSkipPrefs() {
        if (skipPrefsLoaded) return;
        const res = await api('GET', '/settings/skip');
        if (res.success) skipPrefs = res.data;
        else skipPrefs = { skip_intros: false, skip_credits: false, skip_recaps: false, show_skip_button: true };
        skipPrefsLoaded = true;
    }

    // Load segments for a media item
    async function loadSegments(mediaId) {
        currentSegments = [];
        activeSegment = null;
        const res = await api('GET', '/media/' + mediaId + '/segments');
        if (res.success && res.data) currentSegments = res.data;
    }

    // Check segments against current playback time (called from updatePlayerUI)
    function checkSegments() {
        if (!currentSegments.length || !skipPrefs) return;
        const video = document.getElementById('videoPlayer');
        const currentTime = video.currentTime + seekOffset;
        const btn = document.getElementById('skipSegmentBtn');
        const label = document.getElementById('skipSegmentLabel');

        let foundSegment = null;
        for (const seg of currentSegments) {
            // Show button 2 seconds before segment starts, hide after it ends
            if (currentTime >= seg.start_seconds - 2 && currentTime < seg.end_seconds) {
                foundSegment = seg;
                break;
            }
        }

        if (foundSegment && foundSegment !== activeSegment) {
            activeSegment = foundSegment;
            const typeLabel = { intro: 'Skip Intro', credits: 'Skip Credits', recap: 'Skip Recap', preview: 'Skip Preview' };
            label.textContent = typeLabel[foundSegment.segment_type] || 'Skip';

            // Auto-skip check
            const autoSkip = (foundSegment.segment_type === 'intro' && skipPrefs.skip_intros)
                || (foundSegment.segment_type === 'credits' && skipPrefs.skip_credits)
                || (foundSegment.segment_type === 'recap' && skipPrefs.skip_recaps);

            if (autoSkip && currentTime >= foundSegment.start_seconds) {
                // Auto-skip: jump to end of segment
                performSkip(foundSegment);
                return;
            }

            // Show skip button if user has show_skip_button enabled
            if (skipPrefs.show_skip_button) {
                btn.style.display = 'flex';
            }
        } else if (!foundSegment && activeSegment) {
            // Left the segment region
            activeSegment = null;
            btn.style.display = 'none';
        }
    }

    // Perform a skip to end of a segment
    function performSkip(seg) {
        const video = document.getElementById('videoPlayer');
        const btn = document.getElementById('skipSegmentBtn');
        btn.style.display = 'none';
        activeSegment = null;

        if (currentPlayMode === 'mpegts') {
            startMpegtsPlay(currentMediaId, localStorage.getItem('token'), seg.end_seconds);
        } else {
            video.currentTime = seg.end_seconds - seekOffset;
        }
    }

    // Skip button click handler
    function skipCurrentSegment() {
        if (activeSegment) performSkip(activeSegment);
    }

    // Destroy all active players
    function destroyPlayers() {
        if (hlsPlayer) { hlsPlayer.destroy(); hlsPlayer = null; }
        if (mpegtsPlayer) {
            mpegtsPlayer.pause();
            mpegtsPlayer.unload();
            mpegtsPlayer.detachMediaElement();
            mpegtsPlayer.destroy();
            mpegtsPlayer = null;
        }
    }

    async function playMedia(mediaId, title) {
        // Check if this item has multiple editions — show picker if so
        const edCheck = await api('GET', '/media/' + mediaId + '/editions');
        if (edCheck.success && edCheck.data.has_editions && edCheck.data.editions && edCheck.data.editions.length > 1) {
            showEditionPicker(edCheck.data.editions, title);
            return;
        }
        playMediaDirect(mediaId, title);
    }

    async function playMediaDirect(mediaId, title) {
        currentMediaId = mediaId;
        const overlay = document.getElementById('playerOverlay');
        const video = document.getElementById('videoPlayer');
        document.getElementById('playerTitle').textContent = title;
        overlay.classList.add('active');
        const token = localStorage.getItem('token');

        // Load skip segments and preferences in parallel with stream info
        loadSkipPrefs();
        loadSegments(mediaId);

        // Fetch stream info
        const info = await api('GET', `/stream/${mediaId}/info`);
        currentStreamInfo = info.success ? info.data : null;
        knownDuration = currentStreamInfo ? (currentStreamInfo.duration_seconds || 0) : 0;
        seekOffset = 0;

        const sel = document.getElementById('qualitySelect');
        let options = '';

        if (currentStreamInfo) {
            const nativeLabel = currentStreamInfo.native_resolution
                ? `Original (${currentStreamInfo.native_resolution}${currentStreamInfo.needs_remux ? ' \u00b7 direct stream' : ''})`
                : 'Original';
            options += `<option value="direct" selected>${nativeLabel}</option>`;

            if (currentStreamInfo.transcode_qualities) {
                currentStreamInfo.transcode_qualities.forEach(q => {
                    options += `<option value="transcode:${q}">${q} (transcode)</option>`;
                });
            }
        } else {
            options = '<option value="direct" selected>Original</option>';
        }
        sel.innerHTML = options;

        // Start playback — MPEGTS for non-native formats, direct for native
        if (currentStreamInfo && currentStreamInfo.needs_remux) {
            startMpegtsPlay(mediaId, token, 0);
        } else {
            startDirectPlay(mediaId, token, 0);
        }
        video.addEventListener('timeupdate', updatePlayerUI);
    }

    function playDirect(mediaId, title) {
        currentMediaId = mediaId;
        const overlay = document.getElementById('playerOverlay');
        const video = document.getElementById('videoPlayer');
        document.getElementById('playerTitle').textContent = title;
        overlay.classList.add('active');
        const token = localStorage.getItem('token');

        const sel = document.getElementById('qualitySelect');
        sel.innerHTML = '<option value="direct" selected>Original</option>';

        startDirectPlay(mediaId, token, 0);
        video.addEventListener('timeupdate', updatePlayerUI);
    }

    // Direct play for native browser formats (MP4/WebM) — supports range requests & seeking
    function startDirectPlay(mediaId, token, startSec) {
        const video = document.getElementById('videoPlayer');
        destroyPlayers();
        currentPlayMode = 'direct';
        seekOffset = 0;

        const url = `/api/v1/stream/${mediaId}/direct?token=${encodeURIComponent(token)}`;
        video.src = url;
        if (startSec > 0) {
            video.currentTime = startSec;
        }
        video.play().catch(e => {
            console.warn('Direct play starting...', e);
            setTimeout(() => video.play().catch(() => {}), 1000);
        });
    }

    // MPEGTS play for non-native formats (MKV/AVI) — Plex-style direct stream
    function startMpegtsPlay(mediaId, token, startSec) {
        const video = document.getElementById('videoPlayer');
        destroyPlayers();
        currentPlayMode = 'mpegts';
        seekOffset = startSec || 0;

        let url = `/api/v1/stream/${mediaId}/direct?token=${encodeURIComponent(token)}`;
        if (seekOffset > 0) {
            url += `&start=${seekOffset.toFixed(1)}`;
        }

        mpegtsPlayer = mpegts.createPlayer({
            type: 'mpegts',
            isLive: true, // piped stream (no defined end)
            url: url,
            duration: knownDuration ? knownDuration * 1000 : undefined,
        }, {
            enableStashBuffer: true,
            stashInitialSize: 512 * 1024, // 512KB initial buffer
            fixAudioTimestampGap: true, // auto-fix A/V sync gaps
            lazyLoad: false,
            autoCleanupSourceBuffer: true,
            autoCleanupMaxBackwardDuration: 300,
            autoCleanupMinBackwardDuration: 120,
        });

        mpegtsPlayer.attachMediaElement(video);
        mpegtsPlayer.load();
        mpegtsPlayer.play();

        mpegtsPlayer.on(mpegts.Events.ERROR, (errorType, errorDetail, errorInfo) => {
            console.error('mpegts.js error:', errorType, errorDetail, errorInfo);
            if (errorType === mpegts.ErrorTypes.NETWORK_ERROR) {
                toast('Stream interrupted — retrying...', 'info');
            } else {
                toast('Playback error: ' + errorDetail, 'error');
            }
        });
    }

    // HLS play for quality-specific transcodes
    function startHLSPlay(mediaId, quality, token) {
        const video = document.getElementById('videoPlayer');
        destroyPlayers();
        currentPlayMode = 'hls';
        seekOffset = 0;

        const masterUrl = `/api/v1/stream/${mediaId}/master.m3u8?token=${encodeURIComponent(token)}`;
        hlsPlayer = new Hls({
            xhrSetup: (xhr, url) => {
                const sep = url.includes('?') ? '&' : '?';
                xhr.open('GET', url + sep + 'token=' + encodeURIComponent(token), true);
            }
        });
        hlsPlayer.loadSource(masterUrl);
        hlsPlayer.attachMedia(video);
        hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
            const levels = hlsPlayer.levels;
            for (let i = 0; i < levels.length; i++) {
                if (levels[i].height + 'p' === quality || levels[i].name === quality) {
                    hlsPlayer.currentLevel = i;
                    break;
                }
            }
            video.play().catch(() => {});
        });
        hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
            if (data.fatal) {
                console.error('HLS error:', data);
                if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                    toast('Transcoding starting... retrying in 3s', 'info');
                    setTimeout(() => hlsPlayer && hlsPlayer.startLoad(), 3000);
                } else {
                    toast('Playback error: ' + data.details, 'error');
                }
            }
        });
    }

    function changeQuality(value) {
        const token = localStorage.getItem('token');
        if (value === 'direct') {
            if (currentStreamInfo && currentStreamInfo.needs_remux) {
                startMpegtsPlay(currentMediaId, token, 0);
            } else {
                startDirectPlay(currentMediaId, token, 0);
            }
        } else if (value.startsWith('transcode:')) {
            const quality = value.replace('transcode:', '');
            startHLSPlay(currentMediaId, quality, token);
        }
    }

    // ──── Edition Picker ────
    function showEditionPicker(editions, title) {
        const list = document.getElementById('editionPickerList');
        list.innerHTML = editions.map(e => {
            const dur = e.duration_seconds ? formatDuration(e.duration_seconds) : '';
            const res = e.resolution || '';
            const codec = e.codec || '';
            const audio = e.audio_codec || '';
            const metaParts = [dur, res, codec, audio].filter(Boolean).join(' \u00b7 ');
            const defBadge = e.is_default ? '<span class="ep-default">Default</span>' : '';
            return `<div class="edition-picker-card" onclick="pickEditionAndPlay('${e.media_item_id}','${(e.display_name || e.title).replace(/'/g,"\\'")}')">
                <span class="ep-type">${e.edition_type} ${defBadge}</span>
                <span class="ep-meta">${metaParts}</span>
                <button class="ep-play">&#9654; Play</button>
            </div>`;
        }).join('');
        document.getElementById('editionPickerOverlay').classList.add('active');
    }

    function pickEditionAndPlay(mediaId, title) {
        closeEditionPicker();
        playMediaDirect(mediaId, title);
    }

    function closeEditionPicker() {
        document.getElementById('editionPickerOverlay').classList.remove('active');
    }

    // Close edition picker on overlay click
    document.getElementById('editionPickerOverlay').addEventListener('click', function(e) {
        if (e.target === this) closeEditionPicker();
    });

    function closePlayer() {
        const overlay = document.getElementById('playerOverlay');
        const video = document.getElementById('videoPlayer');
        overlay.classList.remove('active');
        video.pause();
        video.src = '';
        destroyPlayers();

        // Save watch progress
        if (currentMediaId && video.currentTime > 0) {
            const progress = Math.floor(video.currentTime + seekOffset);
            api('POST', '/watch/'+currentMediaId+'/progress', {
                progress_seconds: progress,
                duration_seconds: knownDuration || Math.floor(video.duration || 0)
            });
        }
        currentMediaId = null;
        currentStreamInfo = null;
        currentPlayMode = null;
        knownDuration = 0;
        seekOffset = 0;
        currentSegments = [];
        activeSegment = null;
        document.getElementById('skipSegmentBtn').style.display = 'none';
    }

    function updatePlayerUI() {
        const video = document.getElementById('videoPlayer');
        const fill = document.getElementById('playerProgressFill');
        const timeEl = document.getElementById('playerTime');

        const totalDuration = (knownDuration > 0) ? knownDuration
            : (isFinite(video.duration) ? video.duration : 0);
        const currentTime = video.currentTime + seekOffset;

        if (totalDuration > 0) {
            fill.style.width = Math.min((currentTime / totalDuration * 100), 100) + '%';
            timeEl.textContent = formatTime(currentTime) + ' / ' + formatTime(totalDuration);
        }

        // Check for skip segments
        checkSegments();
    }

    function togglePlay() { const v=document.getElementById('videoPlayer'); v.paused?v.play():v.pause(); }

    function skipBack() {
        const video = document.getElementById('videoPlayer');
        if (currentPlayMode === 'mpegts') {
            // MPEGTS: restart stream from new position
            const target = Math.max(0, video.currentTime + seekOffset - 10);
            startMpegtsPlay(currentMediaId, localStorage.getItem('token'), target);
        } else {
            video.currentTime = Math.max(0, video.currentTime - 10);
        }
    }

    function skipForward() {
        const video = document.getElementById('videoPlayer');
        if (currentPlayMode === 'mpegts') {
            // MPEGTS: restart stream from new position
            const target = video.currentTime + seekOffset + 10;
            startMpegtsPlay(currentMediaId, localStorage.getItem('token'), target);
        } else {
            video.currentTime += 10;
        }
    }

    function toggleMute() { const v=document.getElementById('videoPlayer'); v.muted=!v.muted; }
    function toggleFullscreen() { const o=document.getElementById('playerOverlay'); document.fullscreenElement?document.exitFullscreen():o.requestFullscreen(); }

    function seekPlayer(e) {
        const video = document.getElementById('videoPlayer');
        const bar = document.getElementById('playerProgress');
        const pct = e.offsetX / bar.offsetWidth;

        const totalDuration = (knownDuration > 0) ? knownDuration
            : (isFinite(video.duration) ? video.duration : 0);
        if (totalDuration <= 0) return;

        const targetTime = pct * totalDuration;

        if (currentPlayMode === 'mpegts') {
            // MPEGTS: restart FFmpeg from seek position (Plex-style)
            startMpegtsPlay(currentMediaId, localStorage.getItem('token'), targetTime);
        } else {
            // Native MP4 or HLS: standard seeking
            video.currentTime = targetTime;
        }
    }

    // Keyboard shortcuts for player
    document.addEventListener('keydown', (e) => {
        if (!document.getElementById('playerOverlay').classList.contains('active')) return;
        switch(e.key) {
            case ' ': e.preventDefault(); togglePlay(); break;
            case 'ArrowLeft': skipBack(); break;
            case 'ArrowRight': skipForward(); break;
            case 'f': toggleFullscreen(); break;
            case 'm': toggleMute(); break;
            case 'Escape': closePlayer(); break;
        }
    });

    // ──────────────────── Profile Avatars ────────────────────
    const AVATAR_PRESETS = [
        { id: 'av-lion',    emoji: '🦁', bg: ['#c0392b','#e74c3c'] },
        { id: 'av-fox',     emoji: '🦊', bg: ['#d35400','#e67e22'] },
        { id: 'av-panda',   emoji: '🐼', bg: ['#2c3e50','#34495e'] },
        { id: 'av-unicorn', emoji: '🦄', bg: ['#8e44ad','#9b59b6'] },
        { id: 'av-owl',     emoji: '🦉', bg: ['#795548','#8d6e63'] },
        { id: 'av-rocket',  emoji: '🚀', bg: ['#1565c0','#1e88e5'] },
        { id: 'av-star',    emoji: '⭐', bg: ['#f9a825','#fdd835'] },
        { id: 'av-alien',   emoji: '👽', bg: ['#2e7d32','#43a047'] },
        { id: 'av-robot',   emoji: '🤖', bg: ['#546e7a','#78909c'] },
        { id: 'av-ghost',   emoji: '👻', bg: ['#5c6bc0','#7986cb'] },
        { id: 'av-ninja',   emoji: '🥷', bg: ['#1a1a2e','#16213e'] },
        { id: 'av-dragon',  emoji: '🐉', bg: ['#b71c1c','#c62828'] },
        { id: 'av-cat',     emoji: '🐱', bg: ['#ff6f00','#ff8f00'] },
        { id: 'av-dog',     emoji: '🐶', bg: ['#6d4c41','#8d6e63'] },
        { id: 'av-bear',    emoji: '🐻', bg: ['#4e342e','#6d4c41'] },
        { id: 'av-penguin', emoji: '🐧', bg: ['#263238','#37474f'] },
    ];

    function getAvatarById(avatarId) {
        return AVATAR_PRESETS.find(a => a.id === avatarId);
    }

    function renderAvatarCircle(avatarId, name, size) {
        const sz = size || 40;
        const av = getAvatarById(avatarId);
        if (av) {
            return `<div style="width:${sz}px;height:${sz}px;border-radius:50%;background:linear-gradient(135deg,${av.bg[0]},${av.bg[1]});display:flex;align-items:center;justify-content:center;font-size:${sz*0.5}px;">${av.emoji}</div>`;
        }
        // Fallback: gradient with initial
        const [bg, circle] = userColor(name || '?');
        const initial = (name || '?')[0].toUpperCase();
        return `<div style="width:${sz}px;height:${sz}px;border-radius:50%;background:radial-gradient(circle,${circle},${bg});display:flex;align-items:center;justify-content:center;font-size:${sz*0.45}px;font-weight:600;color:rgba(255,255,255,0.85);">${initial}</div>`;
    }

    // ──────────────────── Profile Switching (Household) ────────────────────

    async function openProfileSwitch() {
        closeUserDropdown();
        const overlay = document.getElementById('profileSwitchOverlay');
        const grid = document.getElementById('profileSwitchGrid');
        overlay.classList.add('active');

        try {
            const data = await api('GET', '/household/profiles');
            const profiles = (data.success && data.data) ? data.data : [];

            grid.innerHTML = profiles.map(p => {
                const dn = p.display_name || p.username;
                const avatarHtml = renderAvatarCircle(p.avatar_id, dn, 80);
                const isActive = currentUser && currentUser.id === p.id;
                let badges = '';
                if (p.is_kids_profile) badges += '<div class="profile-switch-badge kids">Kids</div>';
                if (p.has_pin) badges += '<div class="profile-switch-badge" style="background:rgba(0,217,255,0.1);color:#00D9FF;border:1px solid rgba(0,217,255,0.2);">&#128274;</div>';
                return `<div class="profile-switch-user ${p.is_kids_profile ? 'kids-profile' : ''} ${isActive ? 'active' : ''}"
                    onclick="switchToProfile('${p.id}', ${p.has_pin})"
                    style="${isActive ? 'border-color:rgba(0,217,255,0.5);box-shadow:0 0 20px rgba(0,217,255,0.2);' : ''}">
                    <div class="profile-switch-avatar">${avatarHtml}</div>
                    <div class="profile-switch-name">${dn}</div>
                    ${badges}
                </div>`;
            }).join('');
        } catch {
            grid.innerHTML = '<div style="color:#5a6a7f;">Could not load profiles</div>';
        }
    }

    function closeProfileSwitch() {
        document.getElementById('profileSwitchOverlay').classList.remove('active');
    }

    async function switchToProfile(profileId, hasPin) {
        // Always require PIN if profile has one, even if re-selecting current profile
        if (hasPin) {
            showInlinePinEntry(profileId);
            return;
        }

        // Same profile, no PIN — just mark picked and proceed
        if (currentUser && currentUser.id === profileId) {
            sessionStorage.setItem('profile_picked', '1');
            closeProfileSwitch();
            closeHouseholdPicker();
            loadHomeView();
            return;
        }

        // Different profile, no PIN — switch immediately
        try {
            const data = await api('POST', '/household/switch', { profile_id: profileId });
            if (data.success) {
                localStorage.setItem('token', data.data.token);
                localStorage.setItem('user', JSON.stringify(data.data.user));
                currentUser = data.data.user;
                sessionStorage.setItem('profile_picked', '1');
                closeProfileSwitch();
                closeHouseholdPicker();
                document.getElementById('userAvatar').textContent = currentUser.username[0].toUpperCase();
                updateTopBarAvatar();
                loadHomeView();
                loadSidebarCounts();
            } else {
                toast(data.error || 'Switch failed', 'error');
            }
        } catch {
            toast('Connection error', 'error');
        }
    }

    // Inline PIN entry for profile switch (used in both overlays)
    let inlinePinTarget = null;
    function showInlinePinEntry(profileId) {
        inlinePinTarget = profileId;
        // Determine which overlay is active
        const hpOverlay = document.getElementById('householdPickerOverlay');
        const psOverlay = document.getElementById('profileSwitchOverlay');
        const isHousehold = hpOverlay.classList.contains('active');
        const container = isHousehold ? hpOverlay : psOverlay;

        let pinDiv = container.querySelector('.hp-pin-overlay');
        if (!pinDiv) {
            pinDiv = document.createElement('div');
            pinDiv.className = 'hp-pin-overlay';
            container.appendChild(pinDiv);
        }

        const pLen = pinLength || 4;
        let boxesHtml = '';
        for (let i = 0; i < pLen; i++) boxesHtml += `<div class="hp-pin-box${i===0?' active':''}" id="hpBox${i}"></div>`;

        pinDiv.innerHTML = `
            <div class="hp-pin-title">Enter PIN</div>
            <div class="hp-pin-boxes">${boxesHtml}</div>
            <div class="hp-pin-error" id="hpPinError"></div>
            <div class="hp-pin-cancel" onclick="hideInlinePinEntry()">Cancel</div>
        `;
        pinDiv.style.display = 'flex';

        // Click anywhere on the PIN overlay to re-focus the hidden input
        pinDiv.onclick = function(e) {
            if (!e.target.classList.contains('hp-pin-cancel')) {
                document.getElementById('hpPinHidden').focus();
            }
        };

        const hi = document.getElementById('hpPinHidden');
        hi.value = '';
        hi.maxLength = pLen;
        setTimeout(() => hi.focus(), 100);
    }

    function hideInlinePinEntry() {
        inlinePinTarget = null;
        document.querySelectorAll('.hp-pin-overlay').forEach(el => el.style.display = 'none');
    }

    document.getElementById('hpPinHidden').addEventListener('input', async function() {
        const pLen = pinLength || 4;
        const val = this.value.replace(/\D/g, '').substring(0, pLen);
        this.value = val;
        for (let i = 0; i < pLen; i++) {
            const box = document.getElementById('hpBox' + i);
            if (!box) continue;
            box.textContent = i < val.length ? '\u25CF' : '';
            box.className = 'hp-pin-box' + (i < val.length ? ' filled' : '') + (i === val.length ? ' active' : '');
        }
        if (val.length === pLen && inlinePinTarget) {
            const errEl = document.getElementById('hpPinError');
            try {
                const data = await api('POST', '/household/switch', { profile_id: inlinePinTarget, pin: val });
                if (data.success) {
                    localStorage.setItem('token', data.data.token);
                    localStorage.setItem('user', JSON.stringify(data.data.user));
                    currentUser = data.data.user;
                    sessionStorage.setItem('profile_picked', '1');
                    hideInlinePinEntry();
                    closeProfileSwitch();
                    closeHouseholdPicker();
                    document.getElementById('userAvatar').textContent = currentUser.username[0].toUpperCase();
                    updateTopBarAvatar();
                    loadHomeView();
                    loadSidebarCounts();
                } else {
                    if (errEl) errEl.textContent = data.error || 'Invalid PIN';
                    this.value = '';
                    for (let i = 0; i < pLen; i++) {
                        const box = document.getElementById('hpBox' + i);
                        if (box) { box.textContent = ''; box.className = 'hp-pin-box' + (i===0?' active':''); }
                    }
                }
            } catch {
                if (errEl) errEl.textContent = 'Connection error';
                this.value = '';
            }
        }
    });

    document.getElementById('hpPinHidden').addEventListener('keydown', function(e) {
        if (e.key === 'Escape') hideInlinePinEntry();
    });

    // ──────────────────── Household "Who's Watching?" Picker ────────────────────

    async function showHouseholdPicker() {
        try {
            const data = await api('GET', '/household/profiles');
            const profiles = (data.success && data.data) ? data.data : [];

            // If only one profile (master with no sub-profiles), skip picker
            if (profiles.length <= 1) {
                sessionStorage.setItem('profile_picked', '1');
                loadHomeView();
                return;
            }

            const overlay = document.getElementById('householdPickerOverlay');
            const grid = document.getElementById('householdPickerGrid');
            overlay.classList.add('active');

            grid.innerHTML = profiles.map(p => {
                const dn = p.display_name || p.username;
                const avatarHtml = renderAvatarCircle(p.avatar_id, dn, 72);
                let badges = '';
                if (p.is_kids_profile) badges += '<div class="household-picker-badge kids">Kids</div>';
                if (p.has_pin) badges += '<div class="household-picker-badge pin">&#128274;</div>';
                return `<div class="household-picker-card ${p.is_kids_profile ? 'kids-profile' : ''}"
                    onclick="switchToProfile('${p.id}', ${p.has_pin})">
                    <div class="household-picker-avatar">${avatarHtml}</div>
                    <div class="household-picker-name">${dn}</div>
                    ${badges}
                </div>`;
            }).join('');
        } catch {
            // On error, skip picker and go to home
            sessionStorage.setItem('profile_picked', '1');
            loadHomeView();
        }
    }

    function closeHouseholdPicker() {
        document.getElementById('householdPickerOverlay').classList.remove('active');
    }

    // ──────────────────── Manage Profiles ────────────────────

    let mpProfiles = [];
    let mpEditingId = null;

    async function openManageProfiles() {
        closeUserDropdown();
        const overlay = document.getElementById('manageProfilesOverlay');
        overlay.classList.add('active');
        await mpLoadProfiles();
    }

    function closeManageProfiles() {
        document.getElementById('manageProfilesOverlay').classList.remove('active');
        document.getElementById('mpFormArea').innerHTML = '';
        mpEditingId = null;
    }

    async function mpLoadProfiles() {
        try {
            const data = await api('GET', '/household/profiles');
            mpProfiles = (data.success && data.data) ? data.data : [];
        } catch { mpProfiles = []; }

        const list = document.getElementById('mpProfileList');
        const subProfiles = mpProfiles.filter(p => !p.is_master);
        const addBtn = document.getElementById('mpAddBtn');

        list.innerHTML = subProfiles.map(p => {
            const dn = p.display_name || p.username;
            const avatarHtml = renderAvatarCircle(p.avatar_id, dn, 44);
            let meta = [];
            if (p.is_kids_profile) meta.push('Kids');
            if (p.max_content_rating) meta.push('Max: ' + p.max_content_rating);
            if (p.has_pin) meta.push('PIN set');
            return `<div class="mp-profile-item">
                <div class="mp-profile-avatar">${avatarHtml}</div>
                <div class="mp-profile-info">
                    <div class="mp-profile-name">${dn}</div>
                    <div class="mp-profile-meta">${meta.join(' · ') || 'No restrictions'}</div>
                </div>
                <div class="mp-profile-actions">
                    <button class="mp-btn-edit" onclick="mpShowEditForm('${p.id}')">Edit</button>
                    <button class="mp-btn-delete" onclick="mpDeleteProfile('${p.id}', '${dn}')">Delete</button>
                </div>
            </div>`;
        }).join('');

        if (subProfiles.length === 0) {
            list.innerHTML = '<div style="color:#5a6a7f;text-align:center;padding:16px;">No sub-profiles yet</div>';
        }

        addBtn.disabled = subProfiles.length >= 5;
        addBtn.textContent = subProfiles.length >= 5 ? 'Maximum 5 profiles reached' : '+ Add Profile';
    }

    function mpRenderForm(title, profile) {
        const isEdit = !!profile;
        const selAvatar = (profile && profile.avatar_id) || '';
        const selKids = profile ? profile.is_kids_profile : false;
        const selRating = (profile && profile.max_content_rating) || '';
        const selName = (profile && profile.display_name) || '';

        const avatarOptions = AVATAR_PRESETS.map(a => {
            const selected = a.id === selAvatar ? ' selected' : '';
            return `<div class="mp-avatar-option${selected}" 
                style="background:linear-gradient(135deg,${a.bg[0]},${a.bg[1]})"
                onclick="mpSelectAvatar(this, '${a.id}')" data-avatar="${a.id}">
                ${a.emoji}
            </div>`;
        }).join('');

        return `<div class="mp-form">
            <div class="mp-form-title">${title}</div>
            <div class="form-group">
                <label>Display Name</label>
                <input type="text" id="mpFormName" value="${selName}" placeholder="e.g. Kids, Guest">
            </div>
            <div class="form-group">
                <label>Avatar</label>
                <div class="mp-avatar-grid">${avatarOptions}</div>
                <input type="hidden" id="mpFormAvatar" value="${selAvatar}">
            </div>
            <div class="mp-form-row">
                <div class="form-group">
                    <label>Max Content Rating</label>
                    <select id="mpFormRating">
                        <option value="" ${selRating===''?'selected':''}>Unrestricted</option>
                        <option value="G" ${selRating==='G'?'selected':''}>G</option>
                        <option value="PG" ${selRating==='PG'?'selected':''}>PG</option>
                        <option value="PG-13" ${selRating==='PG-13'?'selected':''}>PG-13</option>
                        <option value="R" ${selRating==='R'?'selected':''}>R</option>
                        <option value="NC-17" ${selRating==='NC-17'?'selected':''}>NC-17</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>PIN (optional)</label>
                    <input type="text" id="mpFormPin" inputmode="numeric" maxlength="10" placeholder="${isEdit ? 'Leave blank to keep' : '4-digit PIN'}">
                </div>
            </div>
            <div class="form-group">
                <div class="mp-kids-toggle">
                    <input type="checkbox" id="mpFormKids" ${selKids?'checked':''}>
                    <label for="mpFormKids" style="margin:0;color:#e5e5e5;font-size:0.85rem;">Kids Profile</label>
                </div>
            </div>
            <div class="mp-form-actions">
                <button class="mp-form-btn save" onclick="mpSaveForm()">${isEdit ? 'Save Changes' : 'Create Profile'}</button>
                <button class="mp-form-btn cancel" onclick="mpCancelForm()">Cancel</button>
            </div>
        </div>`;
    }

    function mpSelectAvatar(el, avatarId) {
        el.closest('.mp-avatar-grid').querySelectorAll('.mp-avatar-option').forEach(o => o.classList.remove('selected'));
        el.classList.add('selected');
        document.getElementById('mpFormAvatar').value = avatarId;
    }

    function mpShowAddForm() {
        mpEditingId = null;
        document.getElementById('mpFormArea').innerHTML = mpRenderForm('Add Profile', null);
    }

    function mpShowEditForm(profileId) {
        const p = mpProfiles.find(x => x.id === profileId);
        if (!p) return;
        mpEditingId = profileId;
        document.getElementById('mpFormArea').innerHTML = mpRenderForm('Edit Profile', p);
    }

    function mpCancelForm() {
        mpEditingId = null;
        document.getElementById('mpFormArea').innerHTML = '';
    }

    async function mpSaveForm() {
        const name = document.getElementById('mpFormName').value.trim();
        const avatar = document.getElementById('mpFormAvatar').value || null;
        const rating = document.getElementById('mpFormRating').value || null;
        const pin = document.getElementById('mpFormPin').value.trim();
        const kids = document.getElementById('mpFormKids').checked;

        if (!name) { toast('Display name is required', 'error'); return; }

        if (mpEditingId) {
            // Update existing
            const body = {
                display_name: name,
                avatar_id: avatar,
                max_content_rating: rating,
                is_kids_profile: kids,
            };
            if (pin !== '') body.pin = pin;
            const data = await api('PUT', '/household/profiles/' + mpEditingId, body);
            if (data.success) {
                toast('Profile updated');
                mpCancelForm();
                await mpLoadProfiles();
            } else {
                toast(data.error || 'Update failed', 'error');
            }
        } else {
            // Create new
            const body = {
                display_name: name,
                avatar_id: avatar,
                max_content_rating: rating,
                is_kids_profile: kids,
            };
            if (pin !== '') body.pin = pin;
            const data = await api('POST', '/household/profiles', body);
            if (data.success) {
                toast('Profile created');
                mpCancelForm();
                await mpLoadProfiles();
            } else {
                toast(data.error || 'Create failed', 'error');
            }
        }
    }

    async function mpDeleteProfile(profileId, name) {
        if (!confirm('Delete profile "' + name + '"? This cannot be undone.')) return;
        const data = await api('DELETE', '/household/profiles/' + profileId);
        if (data.success) {
            toast('Profile deleted');
            await mpLoadProfiles();
        } else {
            toast(data.error || 'Delete failed', 'error');
        }
    }

    // ──────────────────── Kids Mode Helpers ────────────────────
    function isKidsMode() {
        return currentUser && currentUser.is_kids_profile === true;
    }

    function getUserMaxRating() {
        return (currentUser && currentUser.max_content_rating) || null;
    }

    // ──────────────────── Updated Home View with Recommendations ────────────────────
    // Override loadHomeView to add recommendations and kids banner
    const _origLoadHomeView = loadHomeView;
    loadHomeView = async function() {
        const mc = document.getElementById('mainContent');
        const kidsMode = isKidsMode();

        let kidsBannerHtml = '';
        if (kidsMode) {
            kidsBannerHtml = `
                <div class="kids-banner">
                    <div class="kids-banner-icon">🧒</div>
                    <div>
                        <div class="kids-banner-text">Kids Mode Active</div>
                        <div class="kids-banner-sub">Content is filtered to ${getUserMaxRating() || 'PG'}-rated and below</div>
                    </div>
                </div>`;
        }

        mc.innerHTML = `
            ${kidsBannerHtml}
            <div class="section-header"><h2 class="section-title">Continue Watching</h2></div>
            <div id="continueRow" class="continue-row"></div>
            <div class="section-header"><h2 class="section-title">Recommended For You</h2></div>
            <div id="recoRow" class="reco-row"><div class="spinner"></div></div>
            <div id="bywRows"></div>
            <div class="section-header"><h2 class="section-title">Recently Added</h2></div>
            <div class="media-grid" id="recentGrid"></div>`;

        // Continue Watching
        try {
            const cw = await api('GET', '/watch/continue');
            const row = document.getElementById('continueRow');
            if (cw.success && cw.data && cw.data.length > 0) {
                row.innerHTML = cw.data.map(wh => {
                    const item = wh.media_item || {};
                    const pct = wh.duration_seconds ? Math.round(wh.progress_seconds/wh.duration_seconds*100) : 0;
                    return `<div class="media-card" onclick="playMedia('${item.id}','${item.title||''}')">
                        <div class="media-poster">
                            ${item.poster_path ? '<img src="'+posterSrc(item.poster_path, item.updated_at)+'">' : mediaIcon(item.media_type||'movies')}
                            <div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>
                            <div class="play-overlay"><div class="play-button">&#9654;</div></div>
                        </div>
                        <div class="media-info"><div class="media-title">${item.title||'Unknown'}</div><div class="media-meta">${Math.floor(wh.progress_seconds/60)}/${wh.duration_seconds?Math.floor(wh.duration_seconds/60):'?'} min</div></div>
                    </div>`;
                }).join('');
            } else row.innerHTML = '<div style="color:#5a6a7f;padding:20px;">No items in progress</div>';
        } catch { document.getElementById('continueRow').innerHTML = ''; }

        // Recommendations
        try {
            const reco = await api('GET', '/recommendations');
            const recoRow = document.getElementById('recoRow');
            if (reco.success && reco.data && reco.data.length > 0) {
                recoRow.innerHTML = reco.data.map(item => renderMediaCard(item)).join('');
            } else {
                recoRow.innerHTML = '<div style="color:#5a6a7f;padding:20px;">Watch more to get personalized recommendations</div>';
            }
        } catch { document.getElementById('recoRow').innerHTML = '<div style="color:#5a6a7f;padding:20px;">Recommendations unavailable</div>'; }

        // Because You Watched
        try {
            const byw = await api('GET', '/recommendations/because-you-watched');
            const bywContainer = document.getElementById('bywRows');
            if (byw.success && byw.data && byw.data.length > 0) {
                bywContainer.innerHTML = byw.data.map(row => {
                    const srcTitle = row.source_item ? row.source_item.title : 'Unknown';
                    const items = row.similar_items || [];
                    return `
                        <div class="section-header"><h2 class="section-title">Because You Watched <em>${srcTitle}</em></h2></div>
                        <div class="reco-row">${items.map(item => renderMediaCard(item)).join('')}</div>`;
                }).join('');
            }
        } catch { /* silent fail for BYW */ }

        // Recently Added
        try {
            const libs = await api('GET', '/libraries');
            const grid = document.getElementById('recentGrid');
            if (libs.success && libs.data) {
                const homepageLibs = libs.data.filter(lib => lib.include_in_homepage !== false);
                let allItems = [];
                for (const lib of homepageLibs.slice(0,5)) {
                    const m = await api('GET', '/libraries/'+lib.id+'/media');
                    if (m.success && m.data && m.data.items) allItems = allItems.concat(m.data.items);
                }
                allItems.sort((a,b) => new Date(b.added_at) - new Date(a.added_at));
                grid.innerHTML = allItems.length > 0
                    ? allItems.slice(0,12).map(renderMediaCard).join('')
                    : `<div class="empty-state" style="grid-column:1/-1;"><div class="empty-state-icon">&#128253;</div><div class="empty-state-title">No media yet</div><p>Add libraries and scan them to populate your media</p><button class="btn-primary" style="margin-top:18px;" onclick="navigate('libraries')">Manage Libraries</button></div>`;
            }
        } catch {}
    };

    // ──────────────────── Updated Profile View ────────────────────
    const _origLoadProfileView = loadProfileView;
    loadProfileView = async function() {
        const mc = document.getElementById('mainContent');
        mc.innerHTML = `<div class="section-header"><h2 class="section-title">Edit Profile</h2></div><div class="settings-grid" id="profileGrid"><div class="spinner"></div></div>`;

        const profileData = await api('GET', '/profile');
        if (!profileData.success) { mc.innerHTML = '<div class="empty-state"><div class="empty-state-title">Failed to load profile</div></div>'; return; }
        const u = profileData.data;

        // Get profile settings
        const settingsData = await api('GET', '/profile/settings');
        const settings = settingsData.success ? settingsData.data : {};

        // Get PIN length setting for validation
        let profPinLength = 4;
        try {
            const flSettings = await api('GET', '/auth/fast-login/settings');
            if (flSettings.success && flSettings.data) profPinLength = parseInt(flSettings.data.fast_login_pin_length) || 4;
        } catch(e) {}

        const currentRating = settings.max_content_rating || '';
        const isKids = settings.is_kids_profile || false;
        const currentAvatar = settings.avatar_id || '';

        // Build avatar grid HTML
        const avatarGridHtml = AVATAR_PRESETS.map(av => {
            const sel = (currentAvatar === av.id) ? 'selected' : '';
            return `<div class="avatar-option ${sel}" data-avatar="${av.id}" onclick="selectAvatar('${av.id}')"
                style="background:linear-gradient(135deg,${av.bg[0]},${av.bg[1]});">${av.emoji}</div>`;
        }).join('');

        document.getElementById('profileGrid').innerHTML = `
            <div class="settings-card">
                <h3>Personal Information</h3>
                <div class="form-group"><label>Username</label><input type="text" value="${u.username || ''}" disabled style="opacity:0.6;cursor:not-allowed;"></div>
                <div class="edit-field-row">
                    <div class="form-group"><label>First Name</label><input type="text" id="profFirstName" value="${u.first_name || ''}" placeholder="Enter first name"></div>
                    <div class="form-group"><label>Last Name</label><input type="text" id="profLastName" value="${u.last_name || ''}" placeholder="Enter last name"></div>
                </div>
                <div class="form-group"><label>Email</label><input type="email" id="profEmail" value="${u.email || ''}" placeholder="Enter email"></div>
                <button class="btn-primary" onclick="saveProfile()">Save Changes</button>
            </div>
            <div class="settings-card">
                <h3>Profile Avatar</h3>
                <p style="color:#8a9bae;font-size:0.82rem;margin-bottom:12px;">Choose an avatar for your profile</p>
                <div class="avatar-grid" id="avatarGrid">${avatarGridHtml}</div>
                <input type="hidden" id="profAvatar" value="${currentAvatar}">
                <button class="btn-primary" onclick="saveProfileSettings()" style="margin-top:8px;">Save Avatar</button>
            </div>
            <div class="settings-card">
                <h3>Parental Controls</h3>
                <p style="color:#8a9bae;font-size:0.82rem;margin-bottom:12px;">Set a maximum content rating for this profile. Content above this rating will be hidden.</p>
                <div class="form-group">
                    <label>Maximum Content Rating</label>
                    <select class="rating-select" id="profMaxRating">
                        <option value="" ${!currentRating ? 'selected' : ''}>No Restriction</option>
                        <option value="G" ${currentRating === 'G' ? 'selected' : ''}>G — General Audiences</option>
                        <option value="PG" ${currentRating === 'PG' ? 'selected' : ''}>PG — Parental Guidance</option>
                        <option value="PG-13" ${currentRating === 'PG-13' ? 'selected' : ''}>PG-13 — Parents Strongly Cautioned</option>
                        <option value="R" ${currentRating === 'R' ? 'selected' : ''}>R — Restricted</option>
                        <option value="NC-17" ${currentRating === 'NC-17' ? 'selected' : ''}>NC-17 — Adults Only</option>
                    </select>
                </div>
                <div class="kids-toggle-container">
                    <label class="toggle-switch">
                        <input type="checkbox" id="profKidsMode" ${isKids ? 'checked' : ''}>
                        <span class="toggle-slider"></span>
                    </label>
                    <div>
                        <div style="color:#e5e5e5;font-size:0.85rem;font-weight:600;">Kids Profile</div>
                        <div style="color:#5a6a7f;font-size:0.78rem;">Enables simplified UI and auto-sets rating to PG when turned on</div>
                    </div>
                </div>
                <button class="btn-primary" onclick="saveProfileSettings()" style="margin-top:8px;">Save Parental Settings</button>
            </div>
            <div class="settings-card">
                <h3>Security</h3>
                <div class="form-group">
                    <label>New Password</label>
                    <input type="password" id="profPassword" placeholder="Leave blank to keep current">
                </div>
                <div class="form-group">
                    <label>Confirm Password</label>
                    <input type="password" id="profPasswordConfirm" placeholder="Confirm new password">
                </div>
                <button class="btn-primary" onclick="saveProfilePassword()" style="margin-bottom:20px;">Change Password</button>
                <div style="border-top:1px solid rgba(0,217,255,0.1);padding-top:16px;margin-top:4px;">
                    <h3 style="margin-bottom:12px;">Login PIN</h3>
                    <p style="color:#8a9bae;font-size:0.82rem;margin-bottom:12px;">Set a ${profPinLength}-digit PIN for quick login. ${u.has_pin ? '<span style="color:#51cf66;">PIN is set.</span>' : '<span style="color:#5a6a7f;">No PIN set.</span>'}</p>
                    <div class="form-group">
                        <label>New PIN (${profPinLength} digits)</label>
                        <input type="password" id="profPin" placeholder="Enter ${profPinLength}-digit PIN" maxlength="${profPinLength}" pattern="[0-9]*" inputmode="numeric">
                    </div>
                    <button class="btn-primary" onclick="saveProfilePin(${profPinLength})">Set PIN</button>
                </div>
            </div>
            <div class="settings-card full-width">
                <h3>Overlay Badges</h3>
                <p style="color:#8a9bae;font-size:0.82rem;margin-bottom:16px;">Choose which badges appear on poster cards. Syncs across all your devices.</p>
                <div id="profileOverlayToggles"><div class="spinner"></div></div>
            </div>`;

        // Load overlay prefs into the profile card
        loadProfileOverlayToggles();
    };

    async function loadProfileOverlayToggles() {
        const res = await api('GET', '/settings/display');
        const p = res.success && res.data ? res.data.overlay_settings : {
            resolution_hdr: true, audio_codec: true, ratings: true,
            content_rating: false, edition_type: true, source_type: false
        };
        document.getElementById('profileOverlayToggles').innerHTML = `
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px 24px;">
                <label class="toggle-label" style="margin-bottom:0;display:flex;align-items:center;gap:10px;">
                    <span class="toggle-switch"><input type="checkbox" id="profOvResHdr" ${p.resolution_hdr?'checked':''}><span class="toggle-slider"></span></span>
                    Resolution &amp; HDR
                </label>
                <label class="toggle-label" style="margin-bottom:0;display:flex;align-items:center;gap:10px;">
                    <span class="toggle-switch"><input type="checkbox" id="profOvAudio" ${p.audio_codec?'checked':''}><span class="toggle-slider"></span></span>
                    Audio Codec
                </label>
                <label class="toggle-label" style="margin-bottom:0;display:flex;align-items:center;gap:10px;">
                    <span class="toggle-switch"><input type="checkbox" id="profOvRatings" ${p.ratings?'checked':''}><span class="toggle-slider"></span></span>
                    Ratings
                </label>
                <label class="toggle-label" style="margin-bottom:0;display:flex;align-items:center;gap:10px;">
                    <span class="toggle-switch"><input type="checkbox" id="profOvContentRating" ${p.content_rating?'checked':''}><span class="toggle-slider"></span></span>
                    Content Rating
                </label>
                <label class="toggle-label" style="margin-bottom:0;display:flex;align-items:center;gap:10px;">
                    <span class="toggle-switch"><input type="checkbox" id="profOvEdition" ${p.edition_type?'checked':''}><span class="toggle-slider"></span></span>
                    Edition Type
                </label>
                <label class="toggle-label" style="margin-bottom:0;display:flex;align-items:center;gap:10px;">
                    <span class="toggle-switch"><input type="checkbox" id="profOvSource" ${p.source_type?'checked':''}><span class="toggle-slider"></span></span>
                    Source Type
                </label>
            </div>
            <button class="btn-primary" onclick="saveProfileOverlayPrefs()" style="margin-top:16px;">Save Overlay Settings</button>`;
    }

    async function saveProfileOverlayPrefs() {
        const settings = {
            resolution_hdr: document.getElementById('profOvResHdr').checked,
            audio_codec: document.getElementById('profOvAudio').checked,
            ratings: document.getElementById('profOvRatings').checked,
            content_rating: document.getElementById('profOvContentRating').checked,
            edition_type: document.getElementById('profOvEdition').checked,
            source_type: document.getElementById('profOvSource').checked,
        };
        const d = await api('PUT', '/settings/display', { overlay_settings: settings });
        if (d.success) {
            overlayPrefs = settings;
            toast('Overlay settings saved!');
        } else toast(d.error || 'Failed to save', 'error');
    }

    function selectAvatar(avatarId) {
        document.getElementById('profAvatar').value = avatarId;
        document.querySelectorAll('.avatar-option').forEach(el => {
            el.classList.toggle('selected', el.dataset.avatar === avatarId);
        });
    }

    async function saveProfileSettings() {
        const maxRating = document.getElementById('profMaxRating').value;
        const isKids = document.getElementById('profKidsMode').checked;
        const avatarId = document.getElementById('profAvatar').value;

        const body = {
            max_content_rating: maxRating || '',
            is_kids_profile: isKids,
            avatar_id: avatarId || null
        };

        const d = await api('PUT', '/profile/settings', body);
        if (d.success) {
            toast('Profile settings updated!');
            // Update local user data and token
            if (d.data.user) {
                currentUser = { ...currentUser, ...d.data.user };
                localStorage.setItem('user', JSON.stringify(currentUser));
            }
            if (d.data.token) {
                localStorage.setItem('token', d.data.token);
            }
            // Update avatar in top bar
            updateTopBarAvatar();
        } else toast(d.error || 'Failed to update settings', 'error');
    }

    // ──────────────────── Top Bar Avatar Update ────────────────────
    function updateTopBarAvatar() {
        const avatarEl = document.getElementById('userAvatar');
        if (!currentUser) return;
        const av = currentUser.avatar_id ? getAvatarById(currentUser.avatar_id) : null;
        if (av) {
            avatarEl.innerHTML = av.emoji;
            avatarEl.style.background = `linear-gradient(135deg, ${av.bg[0]}, ${av.bg[1]})`;
            avatarEl.style.fontSize = '1.2rem';
        } else {
            avatarEl.textContent = currentUser.username[0].toUpperCase();
            avatarEl.style.background = 'linear-gradient(135deg, #00D9FF 0%, #0099CC 100%)';
            avatarEl.style.fontSize = '0.95rem';
        }
    }

    // Patch checkAuth to update avatar after login
    const _origCheckAuth = checkAuth;
    checkAuth = async function() {
        await _origCheckAuth();
        if (currentUser) updateTopBarAvatar();
    };

    // Update fast login to use avatars
    const _origFastLoginShowUsers = fastLoginShowUsers;
    fastLoginShowUsers = function() {
        const grid = document.getElementById('fastLoginGrid');
        const pinEntry = document.getElementById('pinEntryContainer');
        const back = document.getElementById('fastLoginBack');
        const title = document.getElementById('fastLoginTitle');
        const fallback = document.querySelector('.fast-login-fallback');
        grid.style.display = 'flex';
        pinEntry.classList.remove('active');
        back.style.display = 'none';
        title.textContent = 'Who\'s Watching?';
        if (fallback) fallback.style.display = '';
        selectedFastUser = null;

        grid.innerHTML = fastLoginUsers.map(u => {
            const dn = u.display_name || u.username;
            const avatarHtml = renderAvatarCircle(u.avatar_id, dn, 100);
            let badges = '';
            if (u.has_pin) badges += '<span class="fast-login-badge pin-set">&#128274;</span>';
            if (u.role === 'admin') badges += '<span class="fast-login-badge admin">&#128081;</span>';
            if (u.is_kids_profile) badges += '<span class="fast-login-badge" style="background:rgba(76,175,80,0.15);color:#4caf50;border:1px solid rgba(76,175,80,0.3);">Kids</span>';
            return `<div class="fast-login-user ${u.is_kids_profile ? 'kids-profile' : ''}" onclick="fastLoginSelectUser('${u.id}')">
                <div class="fast-login-avatar" style="background:none;">${avatarHtml}
                <div class="fast-login-badges" style="position:absolute;bottom:-4px;left:0;right:0;display:flex;justify-content:center;gap:4px;">${badges}</div></div>
                <div class="fast-login-user-name">${dn}</div></div>`;
        }).join('');
    };

    // ──── Sidebar Toggle (Mobile) ────
    function toggleSidebar() {
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('sidebarOverlay');
        sidebar.classList.toggle('open');
        overlay.classList.toggle('active');
    }

    // ──── Keyboard Navigation for Media Grids ────
    function enableGridKeyNav(grid) {
        if (!grid) return;
        const cards = grid.querySelectorAll('.media-card[tabindex]');
        if (cards.length === 0) return;

        grid.addEventListener('keydown', function(e) {
            const focused = document.activeElement;
            if (!focused || !focused.classList.contains('media-card')) return;

            const allCards = [...grid.querySelectorAll('.media-card[tabindex]')];
            const idx = allCards.indexOf(focused);
            if (idx === -1) return;

            // Calculate columns from grid
            const gridStyle = getComputedStyle(grid);
            const cols = gridStyle.gridTemplateColumns.split(' ').length;
            let target = -1;

            switch(e.key) {
                case 'ArrowRight': target = Math.min(idx + 1, allCards.length - 1); break;
                case 'ArrowLeft': target = Math.max(idx - 1, 0); break;
                case 'ArrowDown': target = Math.min(idx + cols, allCards.length - 1); break;
                case 'ArrowUp': target = Math.max(idx - cols, 0); break;
                case 'Enter':
                case ' ':
                    e.preventDefault();
                    focused.click();
                    return;
                default: return;
            }

            if (target !== -1 && target !== idx) {
                e.preventDefault();
                allCards[target].focus();
            }
        });
    }

    // ──── Init ────
    checkAuth();
    </script>
</body>
</html>
